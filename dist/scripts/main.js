/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var live_form_validation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! live-form-validation */ \"./node_modules/live-form-validation/live-form-validation.js\");\n/* harmony import */ var live_form_validation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(live_form_validation__WEBPACK_IMPORTED_MODULE_0__);\n\nwindow.LiveForm = (live_form_validation__WEBPACK_IMPORTED_MODULE_0___default().LiveForm);\nwindow.Nette = (live_form_validation__WEBPACK_IMPORTED_MODULE_0___default().Nette);\n\n(function () {\n  window.Nette.init();\n  window.LiveForm.setOptions({\n    messageErrorPrefix: ''\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUVBQyxNQUFNLENBQUNDLFFBQVAsR0FBa0JGLHNFQUFsQjtBQUNBQyxNQUFNLENBQUNFLEtBQVAsR0FBZUgsbUVBQWY7O0FBRUEsQ0FBQyxZQUFZO0FBQ1hDLEVBQUFBLE1BQU0sQ0FBQ0UsS0FBUCxDQUFhQyxJQUFiO0FBQ0FILEVBQUFBLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkcsVUFBaEIsQ0FBMkI7QUFDekJDLElBQUFBLGtCQUFrQixFQUFFO0FBREssR0FBM0I7QUFHRCxDQUxEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21haW4uanM/OTI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGl2ZUZvcm1WYWxpZGF0aW9uIGZyb20gJ2xpdmUtZm9ybS12YWxpZGF0aW9uJztcblxud2luZG93LkxpdmVGb3JtID0gTGl2ZUZvcm1WYWxpZGF0aW9uLkxpdmVGb3JtO1xud2luZG93Lk5ldHRlID0gTGl2ZUZvcm1WYWxpZGF0aW9uLk5ldHRlO1xuXG4oZnVuY3Rpb24gKCkge1xuICB3aW5kb3cuTmV0dGUuaW5pdCgpO1xuICB3aW5kb3cuTGl2ZUZvcm0uc2V0T3B0aW9ucyh7XG4gICAgbWVzc2FnZUVycm9yUHJlZml4OiAnJ1xuICB9KVxufSkoKTsiXSwibmFtZXMiOlsiTGl2ZUZvcm1WYWxpZGF0aW9uIiwid2luZG93IiwiTGl2ZUZvcm0iLCJOZXR0ZSIsImluaXQiLCJzZXRPcHRpb25zIiwibWVzc2FnZUVycm9yUHJlZml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/main.js\n");

/***/ }),

/***/ "./node_modules/live-form-validation/live-form-validation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/live-form-validation/live-form-validation.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Live Form Validation for Nette Forms 3.0\n *\n * @author Robert Pösel, zakrava, Radek Ježdík, MartyIX, David Grudl\n * @version 2.0-dev\n * @url https://github.com/Robyer/nette-live-form-validation/\n */\n\n(function (global, factoryLiveValidation, factoryNetteForm) {\n\n    if (true) {\n        // AMD\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return {\n                LiveForm: factoryLiveValidation(global),\n                Nette: factoryNetteForm(global)\n            }\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else { var init; }\n\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n    'use strict'\n\n\n    var LiveForm = {\n        options: {\n            // CSS class of control's parent where error/valid class should be added; or \"false\" to use control directly\n            showMessageClassOnParent: 'form-group',\n\n            // CSS class of control's parent where error/valid message should be added (fallback to direct parent if not found); or \"false\" to use control's direct parent\n            messageParentClass: false,\n\n            // CSS class for an invalid control\n            controlErrorClass: 'has-error',\n\n            // CSS class for a valid control\n            controlValidClass: 'has-success',\n\n            // CSS class for an error message\n            messageErrorClass: 'help-block text-danger',\n\n            // control with this CSS class will show error/valid message even when control itself is hidden (useful for controls which are hidden and wrapped into special component)\n            enableHiddenMessageClass: 'show-hidden-error',\n\n            // control with this CSS class will have disabled live validation\n            disableLiveValidationClass: 'no-live-validation',\n\n            // control with this CSS class will not show valid message\n            disableShowValidClass: 'no-show-valid',\n\n            // tag that will hold the error/valid message\n            messageTag: 'span',\n\n            // message element id = control id + this postfix\n            messageIdPostfix: '_message',\n\n            // show this html before error message itself\n            messageErrorPrefix: '&nbsp;<i class=\"glyphicon glyphicon-exclamation-sign\" aria-hidden=\"true\"></i>&nbsp;',\n\n            // show all errors when submitting form; or use \"false\" to show only first error\n            showAllErrors: true,\n\n            // show message when valid\n            showValid: false,\n\n            // delay in ms before validating on keyup/keydown; or use \"false\" to disable it\n            wait: false,\n\n            // vertical screen offset in px to scroll after focusing element with error (useful when using fixed navbar menu which may otherwise obscure the element in focus); or use \"false\" for default behavior\n            focusScreenOffsetY: false\n        },\n\n        forms: {}\n    };\n\n    LiveForm.setOptions = function (userOptions) {\n        for (var prop in userOptions) {\n            if (Object.prototype.hasOwnProperty.call(this.options, prop)) {\n                this.options[prop] = userOptions[prop];\n            }\n        }\n    }\n\n// Allow setting options before loading the script just by creating global LiveFormOptions object with options.\n    if (typeof window.LiveFormOptions !== 'undefined') {\n        LiveForm.setOptions(window.LiveFormOptions);\n    }\n\n    LiveForm.isSpecialKey = function (k) {\n        // http://stackoverflow.com/questions/7770561/jquery-javascript-reject-control-keys-on-keydown-event\n        return (k == 20 /* Caps lock */\n            || k == 16 /* Shift */\n            || k == 9 /* Tab */\n            || k == 27 /* Escape Key */\n            || k == 17 /* Control Key */\n            || k == 91 /* Windows Command Key */\n            || k == 19 /* Pause Break */\n            || k == 18 /* Alt Key */\n            || k == 93 /* Right Click Point Key */\n            || (k >= 35 && k <= 40) /* Home, End, Arrow Keys */\n            || k == 45 /* Insert Key */\n            || (k >= 33 && k <= 34) /*Page Down, Page Up */\n            || (k >= 112 && k <= 123) /* F1 - F12 */\n            || (k >= 144 && k <= 145)); /* Num Lock, Scroll Lock */\n    }\n\n    /**\n     * Handlers for all the events that trigger validation\n     * YOU CAN CHANGE these handlers (ie. to use jQuery events instead)\n     */\n    LiveForm.setupHandlers = function (el) {\n        if (this.hasClass(el, this.options.disableLiveValidationClass))\n            return;\n\n        // Check if element was already initialized\n        if (el.getAttribute(\"data-lfv-initialized\"))\n            return;\n\n        // Remember we initialized this element so we won't do it again\n        el.setAttribute('data-lfv-initialized', 'true');\n\n        var handler = function (event) {\n            event = event || window.event;\n            Nette.validateControl(event.target ? event.target : event.srcElement);\n        };\n\n        var self = this;\n\n        el.addEventListener('change', handler);\n        el.addEventListener('blur', handler);\n        el.addEventListener('keydown', function (event) {\n            if (!self.isSpecialKey(event.which) && (self.options.wait === false || self.options.wait >= 200)) {\n                // Hide validation span tag.\n                self.removeClass(self.getGroupElement(this), self.options.controlErrorClass);\n                self.removeClass(self.getGroupElement(this), self.options.controlValidClass);\n\n                var messageEl = self.getMessageElement(this);\n                messageEl.innerHTML = '';\n                messageEl.className = '';\n\n                // Cancel timeout to run validation handler\n                if (self.timeout) {\n                    clearTimeout(self.timeout);\n                }\n            }\n        });\n        el.addEventListener('keyup', function (event) {\n            if (self.options.wait !== false) {\n                event = event || window.event;\n                if (event.keyCode !== 9) {\n                    if (self.timeout) clearTimeout(self.timeout);\n                    self.timeout = setTimeout(function () {\n                        handler(event);\n                    }, self.options.wait);\n                }\n            }\n        });\n    };\n\n    LiveForm.processServerErrors = function (el) {\n        var messageEl = this.getMessageElement(el);\n        var parentEl = this.getMessageParent(el); // This is parent element which contain the error elements\n\n        var errors = [];\n\n        // Find existing error elements by class (from server-validation)\n        var errorEls = parentEl.getElementsByClassName(this.options.messageErrorClass);\n        for (var i = errorEls.length - 1; i > -1; i--) {\n            // Don't touch our main message element\n            if (errorEls[i] == messageEl)\n                continue;\n\n            // Remove only direct children\n            var errorParent = errorEls[i].parentNode;\n            if (errorParent == parentEl) {\n                errors.push(errorEls[i].outerHTML);\n                errorParent.removeChild(errorEls[i]);\n            }\n        }\n\n        // Wrap all server errors into one element\n        if (errors.length > 0) {\n            messageEl.innerHTML = errors.join(\"\");\n        }\n    };\n\n    LiveForm.addError = function (el, message) {\n        // Ignore elements with disabled live validation\n        if (this.hasClass(el, this.options.disableLiveValidationClass))\n            return;\n\n        var groupEl = this.getGroupElement(el);\n        this.setFormProperty(el.form, \"hasError\", true);\n        this.addClass(groupEl, this.options.controlErrorClass);\n\n        if (this.options.showValid) {\n            this.removeClass(groupEl, this.options.controlValidClass);\n        }\n\n        if (!message) {\n            message = '&nbsp;';\n        } else {\n            message = this.options.messageErrorPrefix + message;\n        }\n\n        var messageEl = this.getMessageElement(el);\n        messageEl.innerHTML = message;\n        messageEl.className = this.options.messageErrorClass;\n    };\n\n    LiveForm.removeError = function (el) {\n        // We don't want to remove any errors during onLoadValidation\n        if (this.getFormProperty(el.form, \"onLoadValidation\"))\n            return;\n\n        var groupEl = this.getGroupElement(el);\n        this.removeClass(groupEl, this.options.controlErrorClass);\n\n        var id = el.getAttribute('data-lfv-message-id');\n        if (id) {\n            var messageEl = this.getMessageElement(el);\n            messageEl.innerHTML = '';\n            messageEl.className = '';\n        }\n\n        if (this.options.showValid) {\n            if (this.showValid(el))\n                this.addClass(groupEl, this.options.controlValidClass);\n            else\n                this.removeClass(groupEl, this.options.controlValidClass);\n        }\n    };\n\n    LiveForm.showValid = function (el) {\n        if (el.type) {\n            var type = el.type.toLowerCase();\n            if (type == 'checkbox' || type == 'radio') {\n                return false;\n            }\n        }\n\n        var rules = JSON.parse(el.getAttribute('data-nette-rules'));\n        if (rules === null || rules.length == 0) {\n            return false;\n        }\n\n        if (Nette.getEffectiveValue(el) == '') {\n            return false;\n        }\n\n        if (this.hasClass(el, this.options.disableShowValidClass)) {\n            return false;\n        }\n\n        return true;\n    };\n\n    LiveForm.getGroupElement = function (el) {\n        if (this.options.showMessageClassOnParent === false)\n            return el;\n\n        var groupEl = el;\n\n        while (!this.hasClass(groupEl, this.options.showMessageClassOnParent)) {\n            groupEl = groupEl.parentNode;\n\n            if (groupEl === null) {\n                return el;\n            }\n        }\n\n        return groupEl;\n    }\n\n    LiveForm.getMessageId = function (el) {\n        var tmp = el.id + this.options.messageIdPostfix;\n\n        // For elements without ID, or multi elements (with same name), we must generate whole ID ourselves\n        if (el.name && (!el.id || !el.form.elements[el.name].tagName)) {\n            // Strip possible [] from name\n            var name = el.name.match(/\\[\\]$/) ? el.name.match(/(.*)\\[\\]$/)[1] : el.name;\n            // Generate new ID based on form ID, element name and messageIdPostfix from options\n            tmp = (el.form.id ? el.form.id : 'frm') + '-' + name + this.options.messageIdPostfix;\n        }\n\n        // We want unique ID which doesn't exist yet\n        var id = tmp,\n            i = 0;\n        while (document.getElementById(id)) {\n            id = id + '_' + ++i;\n        }\n\n        return id;\n    }\n\n    LiveForm.getMessageElement = function (el) {\n        // For multi elements (with same name) work only with first element attributes\n        if (el.name && el.name.match(/\\[\\]$/)) {\n            el = el.form.elements[el.name].tagName ? el : el.form.elements[el.name][0];\n        }\n\n        var id = el.getAttribute('data-lfv-message-id');\n        if (!id) {\n            // ID is not specified yet, let's create a new one\n            id = this.getMessageId(el);\n\n            // Remember this id for next use\n            el.setAttribute('data-lfv-message-id', id);\n        }\n\n        var messageEl = document.getElementById(id);\n        if (!messageEl) {\n            // Message element doesn't exist, lets create a new one\n            messageEl = document.createElement(this.options.messageTag);\n            messageEl.id = id;\n            if (el.style.display == 'none' && !this.hasClass(el, this.options.enableHiddenMessageClass)) {\n                messageEl.style.display = 'none';\n            }\n\n            var parentEl = this.getMessageParent(el);\n            if (parentEl === el.parentNode) {\n                parentEl.insertBefore(messageEl, el.nextSibling);\n            } else if (parentEl) {\n                typeof parentEl.append === 'function' ? parentEl.append(messageEl) : parentEl.appendChild(messageEl);\n            }\n        }\n\n        return messageEl;\n    };\n\n    LiveForm.getMessageParent = function (el) {\n        var parentEl = el.parentNode;\n        var parentFound = false;\n\n        if (this.options.messageParentClass !== false) {\n            parentFound = true;\n            while (!this.hasClass(parentEl, this.options.messageParentClass)) {\n                parentEl = parentEl.parentNode;\n\n                if (parentEl === null) {\n                    // We didn't found wanted parent, so use element's direct parent\n                    parentEl = el.parentNode;\n                    parentFound = false;\n                    break;\n                }\n            }\n        }\n\n        // Don't append error message to radio/checkbox input's label, but along label\n        if (el.type) {\n            var type = el.type.toLowerCase();\n            if ((type == 'checkbox' || type == 'radio') && parentEl.tagName == 'LABEL') {\n                parentEl = parentEl.parentNode;\n            }\n        }\n\n        // For multi elements (with same name) use parent's parent as parent (if wanted one is not found)\n        if (!parentFound && el.name && !el.form.elements[el.name].tagName) {\n            parentEl = parentEl.parentNode;\n        }\n\n        return parentEl;\n    }\n\n    LiveForm.addClass = function (el, className) {\n        if (!el.className) {\n            el.className = className;\n        } else if (!this.hasClass(el, className)) {\n            el.className += ' ' + className;\n        }\n    };\n\n    LiveForm.hasClass = function (el, className) {\n        if (el.className)\n            return el.className.match(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'));\n        return false;\n    };\n\n    LiveForm.removeClass = function (el, className) {\n        if (this.hasClass(el, className)) {\n            var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n            var m = el.className.match(reg);\n            el.className = el.className.replace(reg, (m[1] == ' ' && m[2] == ' ') ? ' ' : '');\n        }\n    };\n\n    LiveForm.getFormProperty = function (form, propertyName) {\n        if (form == null || this.forms[form.id] == null)\n            return false;\n\n        return this.forms[form.id][propertyName];\n    };\n\n    LiveForm.setFormProperty = function (form, propertyName, value) {\n        if (form == null)\n            return;\n\n        if (this.forms[form.id] == null)\n            this.forms[form.id] = {};\n\n        this.forms[form.id][propertyName] = value;\n    };\n\n    return LiveForm;\n\n////////////////////////////   modified netteForms.js   ///////////////////////////////////\n\n    /**\n     * NetteForms - simple form validation.\n     *\n     * This file is part of the Nette Framework (https://nette.org)\n     * Copyright (c) 2004 David Grudl (https://davidgrudl.com)\n     */\n    /*\n    (function(global, factory) {\n        if (!global.JSON) {\n            return;\n        }\n        if (typeof define === 'function' && define.amd) {\n            define(function() {\n                return factory(global);\n            });\n        } else if (typeof module === 'object' && typeof module.exports === 'object') {\n            module.exports = factory(global);\n        } else {\n            var init = !global.Nette || !global.Nette.noInit;\n            global.Nette = factory(global);\n            if (init) {\n                global.Nette.initOnLoad();\n            }\n        }\n    }(typeof window !== 'undefined' ? window : this, function(window) {\n    */\n\n}, function (window) {\n    'use strict';\n\n    var Nette = {};\n    var preventFiltering = {};\n    var formToggles = {};\n\n    // LiveForm: original netteForms.js code\n    // Nette.formErrors = [];\n    Nette.version = '3.0';\n\n\n    /**\n     * Function to execute when the DOM is fully loaded.\n     * @private\n     */\n    Nette.onDocumentReady = function (callback) {\n        if (document.readyState !== 'loading') {\n            callback.call(this);\n        } else {\n            document.addEventListener('DOMContentLoaded', callback);\n        }\n    };\n\n\n    /**\n     * Attaches a handler to an event for the element.\n     */\n    Nette.addEvent = function (element, on, callback) {\n        if (element.addEventListener) {\n            element.addEventListener(on, callback);\n        } else if (on === 'DOMContentLoaded') {\n            element.attachEvent('onreadystatechange', function () {\n                if (element.readyState === 'complete') {\n                    callback.call(this);\n                }\n            });\n        } else {\n            element.attachEvent('on' + on, getHandler(callback));\n        }\n    };\n\n    /**\n     * Returns the value of form element.\n     */\n    Nette.getValue = function (elem) {\n        var i;\n        if (!elem) {\n            return null;\n\n        } else if (!elem.tagName) { // RadioNodeList, HTMLCollection, array\n            return elem[0] ? Nette.getValue(elem[0]) : null;\n\n        } else if (elem.type === 'radio') {\n            var elements = elem.form.elements; // prevents problem with name 'item' or 'namedItem'\n            for (i = 0; i < elements.length; i++) {\n                if (elements[i].name === elem.name && elements[i].checked) {\n                    return elements[i].value;\n                }\n            }\n            return null;\n\n        } else if (elem.type === 'file') {\n            return elem.files || elem.value;\n\n        } else if (elem.tagName.toLowerCase() === 'select') {\n            var index = elem.selectedIndex,\n                options = elem.options,\n                values = [];\n\n            if (elem.type === 'select-one') {\n                return index < 0 ? null : options[index].value;\n            }\n\n            for (i = 0; i < options.length; i++) {\n                if (options[i].selected) {\n                    values.push(options[i].value);\n                }\n            }\n            return values;\n\n        } else if (elem.name && elem.name.match(/\\[\\]$/)) { // multiple elements []\n            elements = elem.form.elements[elem.name].tagName ? [elem] : elem.form.elements[elem.name];\n            values = [];\n\n            for (i = 0; i < elements.length; i++) {\n                // LiveForm: original netteForms.js code\n                /*if (elements[i].type !== 'checkbox' || elements[i].checked) {\n                    values.push(elements[i].value);\n                }*/\n                // LiveForm: addition\n                var value = elements[i].value;\n                if (elements[i].type === 'checkbox' && elements[i].checked) {\n                    values.push(value);\n                } else if (elements[i].type !== 'checkbox' && value !== '') {\n                    values.push(value);\n                }\n            }\n            return values;\n\n        } else if (elem.type === 'checkbox') {\n            return elem.checked;\n\n        } else if (elem.tagName.toLowerCase() === 'textarea') {\n            return elem.value.replace('\\r', '');\n\n        } else {\n            return elem.value.replace('\\r', '').replace(/^\\s+|\\s+$/g, '');\n        }\n    };\n\n\n    /**\n     * Returns the effective value of form element.\n     */\n    Nette.getEffectiveValue = function (elem, filter) {\n        var val = Nette.getValue(elem);\n        if (elem.getAttribute) {\n            if (val === elem.getAttribute('data-nette-empty-value')) {\n                val = '';\n            }\n        }\n        if (filter && preventFiltering[elem.name] === undefined) {\n            preventFiltering[elem.name] = true;\n            var ref = {value: val};\n            Nette.validateControl(elem, null, true, ref);\n            val = ref.value;\n            delete preventFiltering[elem.name];\n        }\n        return val;\n    };\n\n\n    /**\n     * Validates form element against given rules.\n     */\n    Nette.validateControl = function (elem, rules, onlyCheck, value, emptyOptional) {\n        // LiveForm: addition\n        // Fix for CheckboxList - validation rules are present always only on first input\n        if (elem.name && elem.name.match(/\\[\\]$/) && elem.type.toLowerCase() == 'checkbox') {\n            elem = elem.form.elements[elem.name].tagName ? elem : elem.form.elements[elem.name][0];\n        }\n\n        elem = elem.tagName ? elem : elem[0]; // RadioNodeList\n        rules = rules || JSON.parse(elem.getAttribute('data-nette-rules') || '[]');\n        value = value === undefined ? {value: Nette.getEffectiveValue(elem)} : value;\n        emptyOptional = emptyOptional || !Nette.validateRule(elem, ':filled', null, value);\n\n        for (var id = 0, len = rules.length; id < len; id++) {\n            var rule = rules[id],\n                op = rule.op.match(/(~)?([^?]+)/),\n                curElem = rule.control ? elem.form.elements.namedItem(rule.control) : elem;\n\n            rule.neg = op[1];\n            rule.op = op[2];\n            rule.condition = !!rule.rules;\n\n            if (!curElem) {\n                continue;\n            } else if (emptyOptional && !rule.condition && rule.op !== ':filled') {\n                continue;\n            }\n\n            curElem = curElem.tagName ? curElem : curElem[0]; // RadioNodeList\n            var success = Nette.validateRule(curElem, rule.op, rule.arg, elem === curElem ? value : undefined);\n\n            if (success === null) {\n                continue;\n            } else if (rule.neg) {\n                success = !success;\n            }\n\n            if (rule.condition && success) {\n                if (!Nette.validateControl(elem, rule.rules, onlyCheck, value, rule.op === ':blank' ? false : emptyOptional)) {\n                    return false;\n                }\n            } else if (!rule.condition && !success) {\n                if (Nette.isDisabled(curElem)) {\n                    continue;\n                }\n                if (!onlyCheck) {\n                    var arr = Array.isArray(rule.arg) ? rule.arg : [rule.arg],\n                        message = rule.msg.replace(/%(value|\\d+)/g, function (foo, m) {\n                            return Nette.getValue(m === 'value' ? curElem : elem.form.elements.namedItem(arr[m].control));\n                        });\n                    Nette.addError(curElem, message);\n                }\n                return false;\n            }\n        }\n\n        if (elem.type === 'number' && !elem.validity.valid) {\n            if (!onlyCheck) {\n                Nette.addError(elem, 'Please enter a valid value.');\n            }\n            return false;\n        }\n\n        // LiveForm: addition\n        if (!onlyCheck) {\n            LiveForm.removeError(elem);\n        }\n\n        return true;\n    };\n\n\n    /**\n     * Validates whole form.\n     */\n    Nette.validateForm = function (sender, onlyCheck) {\n        var form = sender.form || sender,\n            scope = false;\n\n        // LiveForm: addition\n        LiveForm.setFormProperty(form, \"hasError\", false);\n\n        // LiveForm: original netteForms.js code\n        // Nette.formErrors = [];\n\n        if (form['nette-submittedBy'] && form['nette-submittedBy'].getAttribute('formnovalidate') !== null) {\n            var scopeArr = JSON.parse(form['nette-submittedBy'].getAttribute('data-nette-validation-scope') || '[]');\n            if (scopeArr.length) {\n                scope = new RegExp('^(' + scopeArr.join('-|') + '-)');\n            } else {\n                // LiveForm: original netteForms.js code\n                // Nette.showFormErrors(form, []);\n                return true;\n            }\n        }\n\n        var radios = {}, i, elem;\n        // LiveForm: addition\n        var success = true;\n\n        for (i = 0; i < form.elements.length; i++) {\n            elem = form.elements[i];\n\n            if (elem.tagName && !(elem.tagName.toLowerCase() in {input: 1, select: 1, textarea: 1, button: 1})) {\n                continue;\n\n            } else if (elem.type === 'radio') {\n                if (radios[elem.name]) {\n                    continue;\n                }\n                radios[elem.name] = true;\n            }\n\n            if ((scope && !elem.name.replace(/]\\[|\\[|]|$/g, '-').match(scope)) || Nette.isDisabled(elem)) {\n                continue;\n            }\n\n            // LiveForm: addition\n            success = Nette.validateControl(elem) && success;\n            if (!success && !LiveForm.options.showAllErrors) {\n                break;\n            }\n            // LiveForm: original netteForms.js code\n            /*if (!Nette.validateControl(elem, null, onlyCheck) && !Nette.formErrors.length) {\n                return false;\n            }*/\n        }\n\n        // LiveForm: change\n        return success;\n\n        // LiveForm: original netteForms.js code\n        /*var success = !Nette.formErrors.length;\n        Nette.showFormErrors(form, Nette.formErrors);\n        return success;*/\n    };\n\n\n    /**\n     * Check if input is disabled.\n     */\n    Nette.isDisabled = function (elem) {\n        if (elem.type === 'radio') {\n            for (var i = 0, elements = elem.form.elements; i < elements.length; i++) {\n                if (elements[i].name === elem.name && !elements[i].disabled) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return elem.disabled;\n    };\n\n\n    // LiveForm: change\n    /**\n     * Display error message.\n     */\n    Nette.addError = function (elem, message) {\n        // LiveForm: addition\n        var noLiveValidation = LiveForm.hasClass(elem, LiveForm.options.disableLiveValidationClass);\n        // User explicitly disabled live-validation so we want to show simple alerts\n        if (noLiveValidation) {\n            // notify errors for elements with disabled live validation (but only errors and not during onLoadValidation)\n            if (message && !LiveForm.getFormProperty(elem.form, \"hasError\") && !LiveForm.getFormProperty(elem.form, \"onLoadValidation\")) {\n                alert(message);\n            }\n        }\n        if (elem.focus && !LiveForm.getFormProperty(elem.form, \"hasError\")) {\n            if (!LiveForm.focusing) {\n                LiveForm.focusing = true;\n                elem.focus();\n                setTimeout(function () {\n                    LiveForm.focusing = false;\n\n                    // Scroll by defined offset (if enabled)\n                    // NOTE: We use it with setTimetout because IE9 doesn't always catch instant scrollTo request\n                    var focusOffsetY = LiveForm.options.focusScreenOffsetY;\n                    if (focusOffsetY !== false && elem.getBoundingClientRect().top < focusOffsetY) {\n                        window.scrollBy(0, elem.getBoundingClientRect().top - focusOffsetY);\n                    }\n                }, 10);\n            }\n        }\n        if (!noLiveValidation) {\n            LiveForm.addError(elem, message);\n        }\n    };\n\n\n    // LiveForm: original netteForms.js code\n    /*/!**\n     * Adds error message to the queue.\n     *!/\n    Nette.addError = function(elem, message) {\n        Nette.formErrors.push({\n            element: elem,\n            message: message\n        });\n    };*/\n\n\n    // LiveForm: original netteForms.js code\n    /*/!**\n     * Display error messages.\n     *!/\n    Nette.showFormErrors = function(form, errors) {\n        var messages = [],\n            focusElem;\n        for (var i = 0; i < errors.length; i++) {\n            var elem = errors[i].element,\n                message = errors[i].message;\n            if (messages.indexOf(message) < 0) {\n                messages.push(message);\n                if (!focusElem && elem.focus) {\n                    focusElem = elem;\n                }\n            }\n        }\n        if (messages.length) {\n            alert(messages.join('\\n'));\n            if (focusElem) {\n                focusElem.focus();\n            }\n        }\n    };*/\n\n\n    /**\n     * Validates single rule.\n     */\n    Nette.validateRule = function (elem, op, arg, value) {\n        value = value === undefined ? {value: Nette.getEffectiveValue(elem, true)} : value;\n\n        if (op.charAt(0) === ':') {\n            op = op.substr(1);\n        }\n        op = op.replace('::', '_');\n        op = op.replace(/\\\\/g, '');\n\n        var arr = Array.isArray(arg) ? arg.slice(0) : [arg];\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] && arr[i].control) {\n                var control = elem.form.elements.namedItem(arr[i].control);\n                arr[i] = control === elem ? value.value : Nette.getEffectiveValue(control, true);\n            }\n        }\n\n        return Nette.validators[op]\n            ? Nette.validators[op](elem, Array.isArray(arg) ? arr : arr[0], value.value, value)\n            : null;\n    };\n\n\n    Nette.validators = {\n        filled: function (elem, arg, val) {\n            if (elem.type === 'number' && elem.validity.badInput) {\n                return true;\n            }\n            return val !== '' && val !== false && val !== null\n                && (!Array.isArray(val) || !!val.length)\n                && (!window.FileList || !(val instanceof window.FileList) || val.length);\n        },\n\n        blank: function (elem, arg, val) {\n            return !Nette.validators.filled(elem, arg, val);\n        },\n\n        valid: function (elem) {\n            return Nette.validateControl(elem, null, true);\n        },\n\n        equal: function (elem, arg, val) {\n            if (arg === undefined) {\n                return null;\n            }\n\n            function toString(val) {\n                if (typeof val === 'number' || typeof val === 'string') {\n                    return '' + val;\n                } else {\n                    return val === true ? '1' : '';\n                }\n            }\n\n            val = Array.isArray(val) ? val : [val];\n            arg = Array.isArray(arg) ? arg : [arg];\n            loop:\n                for (var i1 = 0, len1 = val.length; i1 < len1; i1++) {\n                    for (var i2 = 0, len2 = arg.length; i2 < len2; i2++) {\n                        if (toString(val[i1]) === toString(arg[i2])) {\n                            continue loop;\n                        }\n                    }\n                    return false;\n                }\n            return true;\n        },\n\n        notEqual: function (elem, arg, val) {\n            return arg === undefined ? null : !Nette.validators.equal(elem, arg, val);\n        },\n\n        minLength: function (elem, arg, val) {\n            if (elem.type === 'number') {\n                if (elem.validity.tooShort) {\n                    return false;\n                } else if (elem.validity.badInput) {\n                    return null;\n                }\n            }\n            return val.length >= arg;\n        },\n\n        maxLength: function (elem, arg, val) {\n            if (elem.type === 'number') {\n                if (elem.validity.tooLong) {\n                    return false;\n                } else if (elem.validity.badInput) {\n                    return null;\n                }\n            }\n            return val.length <= arg;\n        },\n\n        length: function (elem, arg, val) {\n            if (elem.type === 'number') {\n                if (elem.validity.tooShort || elem.validity.tooLong) {\n                    return false;\n                } else if (elem.validity.badInput) {\n                    return null;\n                }\n            }\n            arg = Array.isArray(arg) ? arg : [arg, arg];\n            return (arg[0] === null || val.length >= arg[0]) && (arg[1] === null || val.length <= arg[1]);\n        },\n\n        email: function (elem, arg, val) {\n            return (/^(\"([ !#-[\\]-~]|\\\\[ -~])+\"|[-a-z0-9!#$%&'*+/=?^_`{|}~]+(\\.[-a-z0-9!#$%&'*+/=?^_`{|}~]+)*)@([0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]([-0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]{0,61}[0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF])?\\.)+[a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]([-0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]{0,17}[a-z\\u00C0-\\u02FF\\u0370-\\u1EFF])?$/i).test(val);\n        },\n\n        url: function (elem, arg, val, value) {\n            if (!(/^[a-z\\d+.-]+:/).test(val)) {\n                val = 'http://' + val;\n            }\n            if ((/^https?:\\/\\/((([-_0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]+\\.)*[0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]([-0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]{0,61}[0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF])?\\.)?[a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]([-0-9a-z\\u00C0-\\u02FF\\u0370-\\u1EFF]{0,17}[a-z\\u00C0-\\u02FF\\u0370-\\u1EFF])?|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\[[0-9a-f:]{3,39}\\])(:\\d{1,5})?(\\/\\S*)?$/i).test(val)) {\n                value.value = val;\n                return true;\n            }\n            return false;\n        },\n\n        regexp: function (elem, arg, val) {\n            var parts = typeof arg === 'string' ? arg.match(/^\\/(.*)\\/([imu]*)$/) : false;\n            try {\n                return parts && (new RegExp(parts[1], parts[2].replace('u', ''))).test(val);\n            } catch (e) {\n            } // eslint-disable-line no-empty\n        },\n\n        pattern: function (elem, arg, val, value, caseInsensitive) {\n            if (typeof arg !== 'string') {\n                return null;\n            }\n\n            try {\n                try {\n                    var regExp = new RegExp('^(?:' + arg + ')$', caseInsensitive ? 'ui' : 'u');\n                } catch (e) {\n                    regExp = new RegExp('^(?:' + arg + ')$', caseInsensitive ? 'i' : '');\n                }\n\n                if (window.FileList && val instanceof FileList) {\n                    for (var i = 0; i < val.length; i++) {\n                        if (!regExp.test(val[i].name)) {\n                            return false;\n                        }\n                    }\n\n                    return true;\n                }\n\n                return regExp.test(val);\n            } catch (e) {\n            } // eslint-disable-line no-empty\n        },\n\n        patternCaseInsensitive: function (elem, arg, val) {\n            return Nette.validators.pattern(elem, arg, val, null, true);\n        },\n\n        numeric: function (elem, arg, val) {\n            if (elem.type === 'number' && elem.validity.badInput) {\n                return false;\n            }\n            return (/^[0-9]+$/).test(val);\n        },\n\n        integer: function (elem, arg, val) {\n            if (elem.type === 'number' && elem.validity.badInput) {\n                return false;\n            }\n            return (/^-?[0-9]+$/).test(val);\n        },\n\n        'float': function (elem, arg, val, value) {\n            if (elem.type === 'number' && elem.validity.badInput) {\n                return false;\n            }\n            val = val.replace(/ +/g, '').replace(/,/g, '.');\n            if ((/^-?[0-9]*\\.?[0-9]+$/).test(val)) {\n                value.value = val;\n                return true;\n            }\n            return false;\n        },\n\n        min: function (elem, arg, val) {\n            if (elem.type === 'number') {\n                if (elem.validity.rangeUnderflow) {\n                    return false;\n                } else if (elem.validity.badInput) {\n                    return null;\n                }\n            }\n            return arg === null || parseFloat(val) >= arg;\n        },\n\n        max: function (elem, arg, val) {\n            if (elem.type === 'number') {\n                if (elem.validity.rangeOverflow) {\n                    return false;\n                } else if (elem.validity.badInput) {\n                    return null;\n                }\n            }\n            return arg === null || parseFloat(val) <= arg;\n        },\n\n        range: function (elem, arg, val) {\n            if (elem.type === 'number') {\n                if (elem.validity.rangeUnderflow || elem.validity.rangeOverflow) {\n                    return false;\n                } else if (elem.validity.badInput) {\n                    return null;\n                }\n            }\n            return Array.isArray(arg) ?\n                ((arg[0] === null || parseFloat(val) >= arg[0]) && (arg[1] === null || parseFloat(val) <= arg[1])) : null;\n        },\n\n        submitted: function (elem) {\n            return elem.form['nette-submittedBy'] === elem;\n        },\n\n        fileSize: function (elem, arg, val) {\n            if (window.FileList) {\n                for (var i = 0; i < val.length; i++) {\n                    if (val[i].size > arg) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n\n        image: function (elem, arg, val) {\n            if (window.FileList && val instanceof window.FileList) {\n                for (var i = 0; i < val.length; i++) {\n                    var type = val[i].type;\n                    if (type && type !== 'image/gif' && type !== 'image/png' && type !== 'image/jpeg') {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n\n        'static': function (elem, arg) {\n            return arg;\n        }\n    };\n\n\n    /**\n     * Process all toggles in form.\n     */\n    Nette.toggleForm = function (form, elem) {\n        var i;\n        formToggles = {};\n        for (i = 0; i < form.elements.length; i++) {\n            if (form.elements[i].tagName.toLowerCase() in {input: 1, select: 1, textarea: 1, button: 1}) {\n                Nette.toggleControl(form.elements[i], null, null, !elem);\n            }\n        }\n\n        for (i in formToggles) {\n            Nette.toggle(i, formToggles[i], elem);\n        }\n    };\n\n\n    /**\n     * Process toggles on form element.\n     */\n    Nette.toggleControl = function (elem, rules, success, firsttime, value) {\n        rules = rules || JSON.parse(elem.getAttribute('data-nette-rules') || '[]');\n        value = value === undefined ? {value: Nette.getEffectiveValue(elem)} : value;\n\n        var has = false,\n            handled = [],\n            handler = function () {\n                Nette.toggleForm(elem.form, elem);\n            },\n            curSuccess;\n\n        for (var id = 0, len = rules.length; id < len; id++) {\n            var rule = rules[id],\n                op = rule.op.match(/(~)?([^?]+)/),\n                curElem = rule.control ? elem.form.elements.namedItem(rule.control) : elem;\n\n            if (!curElem) {\n                continue;\n            }\n\n            curSuccess = success;\n            if (success !== false) {\n                rule.neg = op[1];\n                rule.op = op[2];\n                curSuccess = Nette.validateRule(curElem, rule.op, rule.arg, elem === curElem ? value : undefined);\n                if (curSuccess === null) {\n                    continue;\n\n                } else if (rule.neg) {\n                    curSuccess = !curSuccess;\n                }\n                if (!rule.rules) {\n                    success = curSuccess;\n                }\n            }\n\n            if ((rule.rules && Nette.toggleControl(elem, rule.rules, curSuccess, firsttime, value)) || rule.toggle) {\n                has = true;\n                if (firsttime) {\n                    var name = curElem.tagName ? curElem.name : curElem[0].name,\n                        els = curElem.tagName ? curElem.form.elements : curElem;\n\n                    for (var i = 0; i < els.length; i++) {\n                        if (els[i].name === name && handled.indexOf(els[i]) < 0) {\n                            els[i].addEventListener('change', handler);\n                            handled.push(els[i]);\n                        }\n                    }\n                }\n                for (var id2 in rule.toggle || []) {\n                    if (Object.prototype.hasOwnProperty.call(rule.toggle, id2)) {\n                        formToggles[id2] = formToggles[id2] || (rule.toggle[id2] ? curSuccess : !curSuccess);\n                    }\n                }\n            }\n        }\n        return has;\n    };\n\n\n    /**\n     * Displays or hides HTML element.\n     */\n    Nette.toggle = function (selector, visible, srcElement) { // eslint-disable-line no-unused-vars\n        if (/^\\w[\\w.:-]*$/.test(selector)) { // id\n            selector = '#' + selector;\n        }\n        var elems = document.querySelectorAll(selector);\n        for (var i = 0; i < elems.length; i++) {\n            elems[i].hidden = !visible;\n        }\n    };\n\n\n    /**\n     * Setup handlers.\n     */\n    Nette.initForm = function (form) {\n        Nette.toggleForm(form);\n\n        if (form.noValidate) {\n            return;\n        }\n\n        form.noValidate = true;\n\n        // LiveForm: addition\n        LiveForm.forms[form.id] = {\n            hasError: false,\n            onLoadValidation: false\n        };\n\n        form.addEventListener('submit', function (e) {\n            if (!Nette.validateForm(form)) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n        });\n\n        // LiveForm: addition\n        for (var i = 0; i < form.elements.length; i++) {\n            LiveForm.setupHandlers(form.elements[i]);\n            LiveForm.processServerErrors(form.elements[i]);\n        }\n    };\n\n    /**\n     * @private\n     */\n    Nette.initOnLoad = function () {\n        Nette.addEvent(document, 'DOMContentLoaded', function () {\n            // LiveForm: original netteForms.js code\n            /*\n                    for (var i = 0; i < document.forms.length; i++) {\n                        var form = document.forms[i];\n                        for (var j = 0; j < form.elements.length; j++) {\n                            if (form.elements[j].getAttribute('data-nette-rules')) {\n                                Nette.initForm(form);\n                                break;\n                            }\n                        }\n                    }\n                    Nette.addEvent(document.body, 'click', function(e) {\n                        var target = e.target || e.srcElement;\n                        if (target.form && target.type in {submit: 1, image: 1}) {\n                            target.form['nette-submittedBy'] = target;\n                        }\n                    });\n            */\n            // LiveForm: addition\n            Nette.init();\n        });\n    };\n\n    // LiveForm: addition\n    /**\n     * Init function to be called in case usage as module\n     *\n     * @public\n     */\n    Nette.init = function () {\n        for (var i = 0; i < document.forms.length; i++) {\n            var form = document.forms[i];\n            for (var j = 0; j < form.elements.length; j++) {\n                if (form.elements[j].getAttribute('data-nette-rules')) {\n                    Nette.initForm(form);\n\n                    if (LiveForm.hasClass(form, 'validate-on-load')) {\n                        // This is not so nice way, but I don't want to spoil validateForm, validateControl and other methods with another parameter\n                        LiveForm.setFormProperty(form, \"onLoadValidation\", true);\n                        Nette.validateForm(form);\n                        LiveForm.setFormProperty(form, \"onLoadValidation\", false);\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        Nette.addEvent(document.body, 'click', function (e) {\n            var target = e.target || e.srcElement;\n            if (target.form && target.type in {submit: 1, image: 1}) {\n                target.form['nette-submittedBy'] = target;\n            }\n        });\n    };\n\n\n    /**\n     * Determines whether the argument is an array.\n     */\n    Nette.isArray = function (arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n\n\n    /**\n     * Search for a specified value within an array.\n     */\n    Nette.inArray = function (arr, val) {\n        if ([].indexOf) {\n            return arr.indexOf(val) > -1;\n        } else {\n            for (var i = 0; i < arr.length; i++) {\n                if (arr[i] === val) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n\n    /**\n     * Converts string to web safe characters [a-z0-9-] text.\n     */\n    Nette.webalize = function (s) {\n        s = s.toLowerCase();\n        var res = '', i, ch;\n        for (i = 0; i < s.length; i++) {\n            ch = Nette.webalizeTable[s.charAt(i)];\n            res += ch ? ch : s.charAt(i);\n        }\n        return res.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');\n    };\n\n    Nette.webalizeTable = {\\u00e1: 'a', \\u00e4: 'a', \\u010d: 'c', \\u010f: 'd', \\u00e9: 'e', \\u011b: 'e', \\u00ed: 'i', \\u013e: 'l', \\u0148: 'n', \\u00f3: 'o', \\u00f4: 'o', \\u0159: 'r', \\u0161: 's', \\u0165: 't', \\u00fa: 'u', \\u016f: 'u', \\u00fd: 'y', \\u017e: 'z'};\n\n    return Nette;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl2ZS1mb3JtLXZhbGlkYXRpb24vbGl2ZS1mb3JtLXZhbGlkYXRpb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsbUNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFBQSxrR0FBQztBQUNWLE1BQU0sS0FBSyxhQWNOOzs7QUFHTCxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7O0FBRUEsaUlBQWlJO0FBQ2pJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyw2RUFBNkU7O0FBRXBILHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQSxnTEFBZ0w7QUFDaEw7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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d0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXZlLWZvcm0tdmFsaWRhdGlvbi9saXZlLWZvcm0tdmFsaWRhdGlvbi5qcz9hZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGl2ZSBGb3JtIFZhbGlkYXRpb24gZm9yIE5ldHRlIEZvcm1zIDMuMFxuICpcbiAqIEBhdXRob3IgUm9iZXJ0IFDDtnNlbCwgemFrcmF2YSwgUmFkZWsgSmXFvmTDrWssIE1hcnR5SVgsIERhdmlkIEdydWRsXG4gKiBAdmVyc2lvbiAyLjAtZGV2XG4gKiBAdXJsIGh0dHBzOi8vZ2l0aHViLmNvbS9Sb2J5ZXIvbmV0dGUtbGl2ZS1mb3JtLXZhbGlkYXRpb24vXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnlMaXZlVmFsaWRhdGlvbiwgZmFjdG9yeU5ldHRlRm9ybSkge1xuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgTGl2ZUZvcm06IGZhY3RvcnlMaXZlVmFsaWRhdGlvbihnbG9iYWwpLFxuICAgICAgICAgICAgICAgIE5ldHRlOiBmYWN0b3J5TmV0dGVGb3JtKGdsb2JhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLCBDb21tb25KUy1saWtlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgTGl2ZUZvcm06IGZhY3RvcnlMaXZlVmFsaWRhdGlvbihnbG9iYWwpLFxuICAgICAgICAgICAgTmV0dGU6IGZhY3RvcnlOZXR0ZUZvcm0oZ2xvYmFsKVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLkxpdmVGb3JtID0gZmFjdG9yeUxpdmVWYWxpZGF0aW9uKGdsb2JhbCk7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHZhciBpbml0ID0gIWdsb2JhbC5OZXR0ZSB8fCAhZ2xvYmFsLk5ldHRlLm5vSW5pdDtcbiAgICAgICAgZ2xvYmFsLk5ldHRlID0gZmFjdG9yeU5ldHRlRm9ybShnbG9iYWwpO1xuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgZ2xvYmFsLk5ldHRlLmluaXRPbkxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKHdpbmRvdykge1xuICAgICd1c2Ugc3RyaWN0J1xuXG5cbiAgICB2YXIgTGl2ZUZvcm0gPSB7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vIENTUyBjbGFzcyBvZiBjb250cm9sJ3MgcGFyZW50IHdoZXJlIGVycm9yL3ZhbGlkIGNsYXNzIHNob3VsZCBiZSBhZGRlZDsgb3IgXCJmYWxzZVwiIHRvIHVzZSBjb250cm9sIGRpcmVjdGx5XG4gICAgICAgICAgICBzaG93TWVzc2FnZUNsYXNzT25QYXJlbnQ6ICdmb3JtLWdyb3VwJyxcblxuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIG9mIGNvbnRyb2wncyBwYXJlbnQgd2hlcmUgZXJyb3IvdmFsaWQgbWVzc2FnZSBzaG91bGQgYmUgYWRkZWQgKGZhbGxiYWNrIHRvIGRpcmVjdCBwYXJlbnQgaWYgbm90IGZvdW5kKTsgb3IgXCJmYWxzZVwiIHRvIHVzZSBjb250cm9sJ3MgZGlyZWN0IHBhcmVudFxuICAgICAgICAgICAgbWVzc2FnZVBhcmVudENsYXNzOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIGZvciBhbiBpbnZhbGlkIGNvbnRyb2xcbiAgICAgICAgICAgIGNvbnRyb2xFcnJvckNsYXNzOiAnaGFzLWVycm9yJyxcblxuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIGZvciBhIHZhbGlkIGNvbnRyb2xcbiAgICAgICAgICAgIGNvbnRyb2xWYWxpZENsYXNzOiAnaGFzLXN1Y2Nlc3MnLFxuXG4gICAgICAgICAgICAvLyBDU1MgY2xhc3MgZm9yIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIG1lc3NhZ2VFcnJvckNsYXNzOiAnaGVscC1ibG9jayB0ZXh0LWRhbmdlcicsXG5cbiAgICAgICAgICAgIC8vIGNvbnRyb2wgd2l0aCB0aGlzIENTUyBjbGFzcyB3aWxsIHNob3cgZXJyb3IvdmFsaWQgbWVzc2FnZSBldmVuIHdoZW4gY29udHJvbCBpdHNlbGYgaXMgaGlkZGVuICh1c2VmdWwgZm9yIGNvbnRyb2xzIHdoaWNoIGFyZSBoaWRkZW4gYW5kIHdyYXBwZWQgaW50byBzcGVjaWFsIGNvbXBvbmVudClcbiAgICAgICAgICAgIGVuYWJsZUhpZGRlbk1lc3NhZ2VDbGFzczogJ3Nob3ctaGlkZGVuLWVycm9yJyxcblxuICAgICAgICAgICAgLy8gY29udHJvbCB3aXRoIHRoaXMgQ1NTIGNsYXNzIHdpbGwgaGF2ZSBkaXNhYmxlZCBsaXZlIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGRpc2FibGVMaXZlVmFsaWRhdGlvbkNsYXNzOiAnbm8tbGl2ZS12YWxpZGF0aW9uJyxcblxuICAgICAgICAgICAgLy8gY29udHJvbCB3aXRoIHRoaXMgQ1NTIGNsYXNzIHdpbGwgbm90IHNob3cgdmFsaWQgbWVzc2FnZVxuICAgICAgICAgICAgZGlzYWJsZVNob3dWYWxpZENsYXNzOiAnbm8tc2hvdy12YWxpZCcsXG5cbiAgICAgICAgICAgIC8vIHRhZyB0aGF0IHdpbGwgaG9sZCB0aGUgZXJyb3IvdmFsaWQgbWVzc2FnZVxuICAgICAgICAgICAgbWVzc2FnZVRhZzogJ3NwYW4nLFxuXG4gICAgICAgICAgICAvLyBtZXNzYWdlIGVsZW1lbnQgaWQgPSBjb250cm9sIGlkICsgdGhpcyBwb3N0Zml4XG4gICAgICAgICAgICBtZXNzYWdlSWRQb3N0Zml4OiAnX21lc3NhZ2UnLFxuXG4gICAgICAgICAgICAvLyBzaG93IHRoaXMgaHRtbCBiZWZvcmUgZXJyb3IgbWVzc2FnZSBpdHNlbGZcbiAgICAgICAgICAgIG1lc3NhZ2VFcnJvclByZWZpeDogJyZuYnNwOzxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1leGNsYW1hdGlvbi1zaWduXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPiZuYnNwOycsXG5cbiAgICAgICAgICAgIC8vIHNob3cgYWxsIGVycm9ycyB3aGVuIHN1Ym1pdHRpbmcgZm9ybTsgb3IgdXNlIFwiZmFsc2VcIiB0byBzaG93IG9ubHkgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgIHNob3dBbGxFcnJvcnM6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIHNob3cgbWVzc2FnZSB3aGVuIHZhbGlkXG4gICAgICAgICAgICBzaG93VmFsaWQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBkZWxheSBpbiBtcyBiZWZvcmUgdmFsaWRhdGluZyBvbiBrZXl1cC9rZXlkb3duOyBvciB1c2UgXCJmYWxzZVwiIHRvIGRpc2FibGUgaXRcbiAgICAgICAgICAgIHdhaXQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCBzY3JlZW4gb2Zmc2V0IGluIHB4IHRvIHNjcm9sbCBhZnRlciBmb2N1c2luZyBlbGVtZW50IHdpdGggZXJyb3IgKHVzZWZ1bCB3aGVuIHVzaW5nIGZpeGVkIG5hdmJhciBtZW51IHdoaWNoIG1heSBvdGhlcndpc2Ugb2JzY3VyZSB0aGUgZWxlbWVudCBpbiBmb2N1cyk7IG9yIHVzZSBcImZhbHNlXCIgZm9yIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIGZvY3VzU2NyZWVuT2Zmc2V0WTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBmb3Jtczoge31cbiAgICB9O1xuXG4gICAgTGl2ZUZvcm0uc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICh1c2VyT3B0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHVzZXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3B0aW9ucywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbcHJvcF0gPSB1c2VyT3B0aW9uc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuLy8gQWxsb3cgc2V0dGluZyBvcHRpb25zIGJlZm9yZSBsb2FkaW5nIHRoZSBzY3JpcHQganVzdCBieSBjcmVhdGluZyBnbG9iYWwgTGl2ZUZvcm1PcHRpb25zIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuTGl2ZUZvcm1PcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBMaXZlRm9ybS5zZXRPcHRpb25zKHdpbmRvdy5MaXZlRm9ybU9wdGlvbnMpO1xuICAgIH1cblxuICAgIExpdmVGb3JtLmlzU3BlY2lhbEtleSA9IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzc3MDU2MS9qcXVlcnktamF2YXNjcmlwdC1yZWplY3QtY29udHJvbC1rZXlzLW9uLWtleWRvd24tZXZlbnRcbiAgICAgICAgcmV0dXJuIChrID09IDIwIC8qIENhcHMgbG9jayAqL1xuICAgICAgICAgICAgfHwgayA9PSAxNiAvKiBTaGlmdCAqL1xuICAgICAgICAgICAgfHwgayA9PSA5IC8qIFRhYiAqL1xuICAgICAgICAgICAgfHwgayA9PSAyNyAvKiBFc2NhcGUgS2V5ICovXG4gICAgICAgICAgICB8fCBrID09IDE3IC8qIENvbnRyb2wgS2V5ICovXG4gICAgICAgICAgICB8fCBrID09IDkxIC8qIFdpbmRvd3MgQ29tbWFuZCBLZXkgKi9cbiAgICAgICAgICAgIHx8IGsgPT0gMTkgLyogUGF1c2UgQnJlYWsgKi9cbiAgICAgICAgICAgIHx8IGsgPT0gMTggLyogQWx0IEtleSAqL1xuICAgICAgICAgICAgfHwgayA9PSA5MyAvKiBSaWdodCBDbGljayBQb2ludCBLZXkgKi9cbiAgICAgICAgICAgIHx8IChrID49IDM1ICYmIGsgPD0gNDApIC8qIEhvbWUsIEVuZCwgQXJyb3cgS2V5cyAqL1xuICAgICAgICAgICAgfHwgayA9PSA0NSAvKiBJbnNlcnQgS2V5ICovXG4gICAgICAgICAgICB8fCAoayA+PSAzMyAmJiBrIDw9IDM0KSAvKlBhZ2UgRG93biwgUGFnZSBVcCAqL1xuICAgICAgICAgICAgfHwgKGsgPj0gMTEyICYmIGsgPD0gMTIzKSAvKiBGMSAtIEYxMiAqL1xuICAgICAgICAgICAgfHwgKGsgPj0gMTQ0ICYmIGsgPD0gMTQ1KSk7IC8qIE51bSBMb2NrLCBTY3JvbGwgTG9jayAqL1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXJzIGZvciBhbGwgdGhlIGV2ZW50cyB0aGF0IHRyaWdnZXIgdmFsaWRhdGlvblxuICAgICAqIFlPVSBDQU4gQ0hBTkdFIHRoZXNlIGhhbmRsZXJzIChpZS4gdG8gdXNlIGpRdWVyeSBldmVudHMgaW5zdGVhZClcbiAgICAgKi9cbiAgICBMaXZlRm9ybS5zZXR1cEhhbmRsZXJzID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKGVsLCB0aGlzLm9wdGlvbnMuZGlzYWJsZUxpdmVWYWxpZGF0aW9uQ2xhc3MpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbGZ2LWluaXRpYWxpemVkXCIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHdlIGluaXRpYWxpemVkIHRoaXMgZWxlbWVudCBzbyB3ZSB3b24ndCBkbyBpdCBhZ2FpblxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGZ2LWluaXRpYWxpemVkJywgJ3RydWUnKTtcblxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICBOZXR0ZS52YWxpZGF0ZUNvbnRyb2woZXZlbnQudGFyZ2V0ID8gZXZlbnQudGFyZ2V0IDogZXZlbnQuc3JjRWxlbWVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlcik7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc1NwZWNpYWxLZXkoZXZlbnQud2hpY2gpICYmIChzZWxmLm9wdGlvbnMud2FpdCA9PT0gZmFsc2UgfHwgc2VsZi5vcHRpb25zLndhaXQgPj0gMjAwKSkge1xuICAgICAgICAgICAgICAgIC8vIEhpZGUgdmFsaWRhdGlvbiBzcGFuIHRhZy5cbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKHNlbGYuZ2V0R3JvdXBFbGVtZW50KHRoaXMpLCBzZWxmLm9wdGlvbnMuY29udHJvbEVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3Moc2VsZi5nZXRHcm91cEVsZW1lbnQodGhpcyksIHNlbGYub3B0aW9ucy5jb250cm9sVmFsaWRDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZUVsID0gc2VsZi5nZXRNZXNzYWdlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUVsLmNsYXNzTmFtZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRpbWVvdXQgdG8gcnVuIHZhbGlkYXRpb24gaGFuZGxlclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMud2FpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPT0gOSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi50aW1lb3V0KSBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VsZi5vcHRpb25zLndhaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpdmVGb3JtLnByb2Nlc3NTZXJ2ZXJFcnJvcnMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VFbCA9IHRoaXMuZ2V0TWVzc2FnZUVsZW1lbnQoZWwpO1xuICAgICAgICB2YXIgcGFyZW50RWwgPSB0aGlzLmdldE1lc3NhZ2VQYXJlbnQoZWwpOyAvLyBUaGlzIGlzIHBhcmVudCBlbGVtZW50IHdoaWNoIGNvbnRhaW4gdGhlIGVycm9yIGVsZW1lbnRzXG5cbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuXG4gICAgICAgIC8vIEZpbmQgZXhpc3RpbmcgZXJyb3IgZWxlbWVudHMgYnkgY2xhc3MgKGZyb20gc2VydmVyLXZhbGlkYXRpb24pXG4gICAgICAgIHZhciBlcnJvckVscyA9IHBhcmVudEVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUodGhpcy5vcHRpb25zLm1lc3NhZ2VFcnJvckNsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGVycm9yRWxzLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB0b3VjaCBvdXIgbWFpbiBtZXNzYWdlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChlcnJvckVsc1tpXSA9PSBtZXNzYWdlRWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBvbmx5IGRpcmVjdCBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIGVycm9yUGFyZW50ID0gZXJyb3JFbHNbaV0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChlcnJvclBhcmVudCA9PSBwYXJlbnRFbCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yRWxzW2ldLm91dGVySFRNTCk7XG4gICAgICAgICAgICAgICAgZXJyb3JQYXJlbnQucmVtb3ZlQ2hpbGQoZXJyb3JFbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JhcCBhbGwgc2VydmVyIGVycm9ycyBpbnRvIG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWVzc2FnZUVsLmlubmVySFRNTCA9IGVycm9ycy5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpdmVGb3JtLmFkZEVycm9yID0gZnVuY3Rpb24gKGVsLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIElnbm9yZSBlbGVtZW50cyB3aXRoIGRpc2FibGVkIGxpdmUgdmFsaWRhdGlvblxuICAgICAgICBpZiAodGhpcy5oYXNDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmRpc2FibGVMaXZlVmFsaWRhdGlvbkNsYXNzKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZ3JvdXBFbCA9IHRoaXMuZ2V0R3JvdXBFbGVtZW50KGVsKTtcbiAgICAgICAgdGhpcy5zZXRGb3JtUHJvcGVydHkoZWwuZm9ybSwgXCJoYXNFcnJvclwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcyhncm91cEVsLCB0aGlzLm9wdGlvbnMuY29udHJvbEVycm9yQ2xhc3MpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd1ZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKGdyb3VwRWwsIHRoaXMub3B0aW9ucy5jb250cm9sVmFsaWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnJm5ic3A7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZUVycm9yUHJlZml4ICsgbWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXNzYWdlRWwgPSB0aGlzLmdldE1lc3NhZ2VFbGVtZW50KGVsKTtcbiAgICAgICAgbWVzc2FnZUVsLmlubmVySFRNTCA9IG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2VFbC5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMubWVzc2FnZUVycm9yQ2xhc3M7XG4gICAgfTtcblxuICAgIExpdmVGb3JtLnJlbW92ZUVycm9yID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmVtb3ZlIGFueSBlcnJvcnMgZHVyaW5nIG9uTG9hZFZhbGlkYXRpb25cbiAgICAgICAgaWYgKHRoaXMuZ2V0Rm9ybVByb3BlcnR5KGVsLmZvcm0sIFwib25Mb2FkVmFsaWRhdGlvblwiKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZ3JvdXBFbCA9IHRoaXMuZ2V0R3JvdXBFbGVtZW50KGVsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhncm91cEVsLCB0aGlzLm9wdGlvbnMuY29udHJvbEVycm9yQ2xhc3MpO1xuXG4gICAgICAgIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1sZnYtbWVzc2FnZS1pZCcpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRWwgPSB0aGlzLmdldE1lc3NhZ2VFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIG1lc3NhZ2VFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIG1lc3NhZ2VFbC5jbGFzc05hbWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG93VmFsaWQoZWwpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoZ3JvdXBFbCwgdGhpcy5vcHRpb25zLmNvbnRyb2xWYWxpZENsYXNzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKGdyb3VwRWwsIHRoaXMub3B0aW9ucy5jb250cm9sVmFsaWRDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl2ZUZvcm0uc2hvd1ZhbGlkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGVsLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09ICdjaGVja2JveCcgfHwgdHlwZSA9PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJ1bGVzID0gSlNPTi5wYXJzZShlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV0dGUtcnVsZXMnKSk7XG4gICAgICAgIGlmIChydWxlcyA9PT0gbnVsbCB8fCBydWxlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5ldHRlLmdldEVmZmVjdGl2ZVZhbHVlKGVsKSA9PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5kaXNhYmxlU2hvd1ZhbGlkQ2xhc3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgTGl2ZUZvcm0uZ2V0R3JvdXBFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd01lc3NhZ2VDbGFzc09uUGFyZW50ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBlbDtcblxuICAgICAgICB2YXIgZ3JvdXBFbCA9IGVsO1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5oYXNDbGFzcyhncm91cEVsLCB0aGlzLm9wdGlvbnMuc2hvd01lc3NhZ2VDbGFzc09uUGFyZW50KSkge1xuICAgICAgICAgICAgZ3JvdXBFbCA9IGdyb3VwRWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwRWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBFbDtcbiAgICB9XG5cbiAgICBMaXZlRm9ybS5nZXRNZXNzYWdlSWQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHRtcCA9IGVsLmlkICsgdGhpcy5vcHRpb25zLm1lc3NhZ2VJZFBvc3RmaXg7XG5cbiAgICAgICAgLy8gRm9yIGVsZW1lbnRzIHdpdGhvdXQgSUQsIG9yIG11bHRpIGVsZW1lbnRzICh3aXRoIHNhbWUgbmFtZSksIHdlIG11c3QgZ2VuZXJhdGUgd2hvbGUgSUQgb3Vyc2VsdmVzXG4gICAgICAgIGlmIChlbC5uYW1lICYmICghZWwuaWQgfHwgIWVsLmZvcm0uZWxlbWVudHNbZWwubmFtZV0udGFnTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIFN0cmlwIHBvc3NpYmxlIFtdIGZyb20gbmFtZVxuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbC5uYW1lLm1hdGNoKC9cXFtcXF0kLykgPyBlbC5uYW1lLm1hdGNoKC8oLiopXFxbXFxdJC8pWzFdIDogZWwubmFtZTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIG5ldyBJRCBiYXNlZCBvbiBmb3JtIElELCBlbGVtZW50IG5hbWUgYW5kIG1lc3NhZ2VJZFBvc3RmaXggZnJvbSBvcHRpb25zXG4gICAgICAgICAgICB0bXAgPSAoZWwuZm9ybS5pZCA/IGVsLmZvcm0uaWQgOiAnZnJtJykgKyAnLScgKyBuYW1lICsgdGhpcy5vcHRpb25zLm1lc3NhZ2VJZFBvc3RmaXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSB3YW50IHVuaXF1ZSBJRCB3aGljaCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICB2YXIgaWQgPSB0bXAsXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSkge1xuICAgICAgICAgICAgaWQgPSBpZCArICdfJyArICsraTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBMaXZlRm9ybS5nZXRNZXNzYWdlRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAvLyBGb3IgbXVsdGkgZWxlbWVudHMgKHdpdGggc2FtZSBuYW1lKSB3b3JrIG9ubHkgd2l0aCBmaXJzdCBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKGVsLm5hbWUgJiYgZWwubmFtZS5tYXRjaCgvXFxbXFxdJC8pKSB7XG4gICAgICAgICAgICBlbCA9IGVsLmZvcm0uZWxlbWVudHNbZWwubmFtZV0udGFnTmFtZSA/IGVsIDogZWwuZm9ybS5lbGVtZW50c1tlbC5uYW1lXVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1sZnYtbWVzc2FnZS1pZCcpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAvLyBJRCBpcyBub3Qgc3BlY2lmaWVkIHlldCwgbGV0J3MgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgaWQgPSB0aGlzLmdldE1lc3NhZ2VJZChlbCk7XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgaWQgZm9yIG5leHQgdXNlXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGZ2LW1lc3NhZ2UtaWQnLCBpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVzc2FnZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICBpZiAoIW1lc3NhZ2VFbCkge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QsIGxldHMgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgbWVzc2FnZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm9wdGlvbnMubWVzc2FnZVRhZyk7XG4gICAgICAgICAgICBtZXNzYWdlRWwuaWQgPSBpZDtcbiAgICAgICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09ICdub25lJyAmJiAhdGhpcy5oYXNDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmVuYWJsZUhpZGRlbk1lc3NhZ2VDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5nZXRNZXNzYWdlUGFyZW50KGVsKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRFbCA9PT0gZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShtZXNzYWdlRWwsIGVsLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50RWwpIHtcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGFyZW50RWwuYXBwZW5kID09PSAnZnVuY3Rpb24nID8gcGFyZW50RWwuYXBwZW5kKG1lc3NhZ2VFbCkgOiBwYXJlbnRFbC5hcHBlbmRDaGlsZChtZXNzYWdlRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VFbDtcbiAgICB9O1xuXG4gICAgTGl2ZUZvcm0uZ2V0TWVzc2FnZVBhcmVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgcGFyZW50Rm91bmQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lc3NhZ2VQYXJlbnRDbGFzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHBhcmVudEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICghdGhpcy5oYXNDbGFzcyhwYXJlbnRFbCwgdGhpcy5vcHRpb25zLm1lc3NhZ2VQYXJlbnRDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbCA9IHBhcmVudEVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZGlkbid0IGZvdW5kIHdhbnRlZCBwYXJlbnQsIHNvIHVzZSBlbGVtZW50J3MgZGlyZWN0IHBhcmVudFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IGFwcGVuZCBlcnJvciBtZXNzYWdlIHRvIHJhZGlvL2NoZWNrYm94IGlucHV0J3MgbGFiZWwsIGJ1dCBhbG9uZyBsYWJlbFxuICAgICAgICBpZiAoZWwudHlwZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBlbC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoKHR5cGUgPT0gJ2NoZWNrYm94JyB8fCB0eXBlID09ICdyYWRpbycpICYmIHBhcmVudEVsLnRhZ05hbWUgPT0gJ0xBQkVMJykge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBtdWx0aSBlbGVtZW50cyAod2l0aCBzYW1lIG5hbWUpIHVzZSBwYXJlbnQncyBwYXJlbnQgYXMgcGFyZW50IChpZiB3YW50ZWQgb25lIGlzIG5vdCBmb3VuZClcbiAgICAgICAgaWYgKCFwYXJlbnRGb3VuZCAmJiBlbC5uYW1lICYmICFlbC5mb3JtLmVsZW1lbnRzW2VsLm5hbWVdLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRFbDtcbiAgICB9XG5cbiAgICBMaXZlRm9ybS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl2ZUZvcm0uaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWwuY2xhc3NOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBMaXZlRm9ybS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNsYXNzTmFtZSArICcoXFxcXHN8JCknKTtcbiAgICAgICAgICAgIHZhciBtID0gZWwuY2xhc3NOYW1lLm1hdGNoKHJlZyk7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShyZWcsIChtWzFdID09ICcgJyAmJiBtWzJdID09ICcgJykgPyAnICcgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGl2ZUZvcm0uZ2V0Rm9ybVByb3BlcnR5ID0gZnVuY3Rpb24gKGZvcm0sIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoZm9ybSA9PSBudWxsIHx8IHRoaXMuZm9ybXNbZm9ybS5pZF0gPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3Jtc1tmb3JtLmlkXVtwcm9wZXJ0eU5hbWVdO1xuICAgIH07XG5cbiAgICBMaXZlRm9ybS5zZXRGb3JtUHJvcGVydHkgPSBmdW5jdGlvbiAoZm9ybSwgcHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZm9ybSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLmZvcm1zW2Zvcm0uaWRdID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLmZvcm1zW2Zvcm0uaWRdID0ge307XG5cbiAgICAgICAgdGhpcy5mb3Jtc1tmb3JtLmlkXVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfTtcblxuICAgIHJldHVybiBMaXZlRm9ybTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIG1vZGlmaWVkIG5ldHRlRm9ybXMuanMgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogTmV0dGVGb3JtcyAtIHNpbXBsZSBmb3JtIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgTmV0dGUgRnJhbWV3b3JrIChodHRwczovL25ldHRlLm9yZylcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDQgRGF2aWQgR3J1ZGwgKGh0dHBzOi8vZGF2aWRncnVkbC5jb20pXG4gICAgICovXG4gICAgLypcbiAgICAoZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmICghZ2xvYmFsLkpTT04pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoZ2xvYmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluaXQgPSAhZ2xvYmFsLk5ldHRlIHx8ICFnbG9iYWwuTmV0dGUubm9Jbml0O1xuICAgICAgICAgICAgZ2xvYmFsLk5ldHRlID0gZmFjdG9yeShnbG9iYWwpO1xuICAgICAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWwuTmV0dGUuaW5pdE9uTG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICovXG5cbn0sIGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgTmV0dGUgPSB7fTtcbiAgICB2YXIgcHJldmVudEZpbHRlcmluZyA9IHt9O1xuICAgIHZhciBmb3JtVG9nZ2xlcyA9IHt9O1xuXG4gICAgLy8gTGl2ZUZvcm06IG9yaWdpbmFsIG5ldHRlRm9ybXMuanMgY29kZVxuICAgIC8vIE5ldHRlLmZvcm1FcnJvcnMgPSBbXTtcbiAgICBOZXR0ZS52ZXJzaW9uID0gJzMuMCc7XG5cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgRE9NIGlzIGZ1bGx5IGxvYWRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5ldHRlLm9uRG9jdW1lbnRSZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgaGFuZGxlciB0byBhbiBldmVudCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgTmV0dGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihvbiwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2UgaWYgKG9uID09PSAnRE9NQ29udGVudExvYWRlZCcpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBvbiwgZ2V0SGFuZGxlcihjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGZvcm0gZWxlbWVudC5cbiAgICAgKi9cbiAgICBOZXR0ZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIWVsZW0udGFnTmFtZSkgeyAvLyBSYWRpb05vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiwgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBlbGVtWzBdID8gTmV0dGUuZ2V0VmFsdWUoZWxlbVswXSkgOiBudWxsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBlbGVtLmZvcm0uZWxlbWVudHM7IC8vIHByZXZlbnRzIHByb2JsZW0gd2l0aCBuYW1lICdpdGVtJyBvciAnbmFtZWRJdGVtJ1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5hbWUgPT09IGVsZW0ubmFtZSAmJiBlbGVtZW50c1tpXS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9IGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5maWxlcyB8fCBlbGVtLnZhbHVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ3NlbGVjdC1vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBvcHRpb25zW2luZGV4XS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5uYW1lICYmIGVsZW0ubmFtZS5tYXRjaCgvXFxbXFxdJC8pKSB7IC8vIG11bHRpcGxlIGVsZW1lbnRzIFtdXG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW0uZm9ybS5lbGVtZW50c1tlbGVtLm5hbWVdLnRhZ05hbWUgPyBbZWxlbV0gOiBlbGVtLmZvcm0uZWxlbWVudHNbZWxlbS5uYW1lXTtcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBMaXZlRm9ybTogb3JpZ2luYWwgbmV0dGVGb3Jtcy5qcyBjb2RlXG4gICAgICAgICAgICAgICAgLyppZiAoZWxlbWVudHNbaV0udHlwZSAhPT0gJ2NoZWNrYm94JyB8fCBlbGVtZW50c1tpXS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGVsZW1lbnRzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgICAvLyBMaXZlRm9ybTogYWRkaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50c1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0udHlwZSA9PT0gJ2NoZWNrYm94JyAmJiBlbGVtZW50c1tpXS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzW2ldLnR5cGUgIT09ICdjaGVja2JveCcgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jaGVja2VkO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLnZhbHVlLnJlcGxhY2UoJ1xccicsICcnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0udmFsdWUucmVwbGFjZSgnXFxyJywgJycpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSB2YWx1ZSBvZiBmb3JtIGVsZW1lbnQuXG4gICAgICovXG4gICAgTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUgPSBmdW5jdGlvbiAoZWxlbSwgZmlsdGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBOZXR0ZS5nZXRWYWx1ZShlbGVtKTtcbiAgICAgICAgaWYgKGVsZW0uZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAodmFsID09PSBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXR0ZS1lbXB0eS12YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlciAmJiBwcmV2ZW50RmlsdGVyaW5nW2VsZW0ubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJldmVudEZpbHRlcmluZ1tlbGVtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZWYgPSB7dmFsdWU6IHZhbH07XG4gICAgICAgICAgICBOZXR0ZS52YWxpZGF0ZUNvbnRyb2woZWxlbSwgbnVsbCwgdHJ1ZSwgcmVmKTtcbiAgICAgICAgICAgIHZhbCA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcmV2ZW50RmlsdGVyaW5nW2VsZW0ubmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgZm9ybSBlbGVtZW50IGFnYWluc3QgZ2l2ZW4gcnVsZXMuXG4gICAgICovXG4gICAgTmV0dGUudmFsaWRhdGVDb250cm9sID0gZnVuY3Rpb24gKGVsZW0sIHJ1bGVzLCBvbmx5Q2hlY2ssIHZhbHVlLCBlbXB0eU9wdGlvbmFsKSB7XG4gICAgICAgIC8vIExpdmVGb3JtOiBhZGRpdGlvblxuICAgICAgICAvLyBGaXggZm9yIENoZWNrYm94TGlzdCAtIHZhbGlkYXRpb24gcnVsZXMgYXJlIHByZXNlbnQgYWx3YXlzIG9ubHkgb24gZmlyc3QgaW5wdXRcbiAgICAgICAgaWYgKGVsZW0ubmFtZSAmJiBlbGVtLm5hbWUubWF0Y2goL1xcW1xcXSQvKSAmJiBlbGVtLnR5cGUudG9Mb3dlckNhc2UoKSA9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5mb3JtLmVsZW1lbnRzW2VsZW0ubmFtZV0udGFnTmFtZSA/IGVsZW0gOiBlbGVtLmZvcm0uZWxlbWVudHNbZWxlbS5uYW1lXVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0gPSBlbGVtLnRhZ05hbWUgPyBlbGVtIDogZWxlbVswXTsgLy8gUmFkaW9Ob2RlTGlzdFxuICAgICAgICBydWxlcyA9IHJ1bGVzIHx8IEpTT04ucGFyc2UoZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV0dGUtcnVsZXMnKSB8fCAnW10nKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8ge3ZhbHVlOiBOZXR0ZS5nZXRFZmZlY3RpdmVWYWx1ZShlbGVtKX0gOiB2YWx1ZTtcbiAgICAgICAgZW1wdHlPcHRpb25hbCA9IGVtcHR5T3B0aW9uYWwgfHwgIU5ldHRlLnZhbGlkYXRlUnVsZShlbGVtLCAnOmZpbGxlZCcsIG51bGwsIHZhbHVlKTtcblxuICAgICAgICBmb3IgKHZhciBpZCA9IDAsIGxlbiA9IHJ1bGVzLmxlbmd0aDsgaWQgPCBsZW47IGlkKyspIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaWRdLFxuICAgICAgICAgICAgICAgIG9wID0gcnVsZS5vcC5tYXRjaCgvKH4pPyhbXj9dKykvKSxcbiAgICAgICAgICAgICAgICBjdXJFbGVtID0gcnVsZS5jb250cm9sID8gZWxlbS5mb3JtLmVsZW1lbnRzLm5hbWVkSXRlbShydWxlLmNvbnRyb2wpIDogZWxlbTtcblxuICAgICAgICAgICAgcnVsZS5uZWcgPSBvcFsxXTtcbiAgICAgICAgICAgIHJ1bGUub3AgPSBvcFsyXTtcbiAgICAgICAgICAgIHJ1bGUuY29uZGl0aW9uID0gISFydWxlLnJ1bGVzO1xuXG4gICAgICAgICAgICBpZiAoIWN1ckVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW1wdHlPcHRpb25hbCAmJiAhcnVsZS5jb25kaXRpb24gJiYgcnVsZS5vcCAhPT0gJzpmaWxsZWQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1ckVsZW0gPSBjdXJFbGVtLnRhZ05hbWUgPyBjdXJFbGVtIDogY3VyRWxlbVswXTsgLy8gUmFkaW9Ob2RlTGlzdFxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBOZXR0ZS52YWxpZGF0ZVJ1bGUoY3VyRWxlbSwgcnVsZS5vcCwgcnVsZS5hcmcsIGVsZW0gPT09IGN1ckVsZW0gPyB2YWx1ZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGlmIChzdWNjZXNzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJ1bGUubmVnKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9ICFzdWNjZXNzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVsZS5jb25kaXRpb24gJiYgc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGlmICghTmV0dGUudmFsaWRhdGVDb250cm9sKGVsZW0sIHJ1bGUucnVsZXMsIG9ubHlDaGVjaywgdmFsdWUsIHJ1bGUub3AgPT09ICc6YmxhbmsnID8gZmFsc2UgOiBlbXB0eU9wdGlvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghcnVsZS5jb25kaXRpb24gJiYgIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoTmV0dGUuaXNEaXNhYmxlZChjdXJFbGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvbmx5Q2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IEFycmF5LmlzQXJyYXkocnVsZS5hcmcpID8gcnVsZS5hcmcgOiBbcnVsZS5hcmddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHJ1bGUubXNnLnJlcGxhY2UoLyUodmFsdWV8XFxkKykvZywgZnVuY3Rpb24gKGZvbywgbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZXR0ZS5nZXRWYWx1ZShtID09PSAndmFsdWUnID8gY3VyRWxlbSA6IGVsZW0uZm9ybS5lbGVtZW50cy5uYW1lZEl0ZW0oYXJyW21dLmNvbnRyb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBOZXR0ZS5hZGRFcnJvcihjdXJFbGVtLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicgJiYgIWVsZW0udmFsaWRpdHkudmFsaWQpIHtcbiAgICAgICAgICAgIGlmICghb25seUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgTmV0dGUuYWRkRXJyb3IoZWxlbSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIHZhbHVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGl2ZUZvcm06IGFkZGl0aW9uXG4gICAgICAgIGlmICghb25seUNoZWNrKSB7XG4gICAgICAgICAgICBMaXZlRm9ybS5yZW1vdmVFcnJvcihlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB3aG9sZSBmb3JtLlxuICAgICAqL1xuICAgIE5ldHRlLnZhbGlkYXRlRm9ybSA9IGZ1bmN0aW9uIChzZW5kZXIsIG9ubHlDaGVjaykge1xuICAgICAgICB2YXIgZm9ybSA9IHNlbmRlci5mb3JtIHx8IHNlbmRlcixcbiAgICAgICAgICAgIHNjb3BlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gTGl2ZUZvcm06IGFkZGl0aW9uXG4gICAgICAgIExpdmVGb3JtLnNldEZvcm1Qcm9wZXJ0eShmb3JtLCBcImhhc0Vycm9yXCIsIGZhbHNlKTtcblxuICAgICAgICAvLyBMaXZlRm9ybTogb3JpZ2luYWwgbmV0dGVGb3Jtcy5qcyBjb2RlXG4gICAgICAgIC8vIE5ldHRlLmZvcm1FcnJvcnMgPSBbXTtcblxuICAgICAgICBpZiAoZm9ybVsnbmV0dGUtc3VibWl0dGVkQnknXSAmJiBmb3JtWyduZXR0ZS1zdWJtaXR0ZWRCeSddLmdldEF0dHJpYnV0ZSgnZm9ybW5vdmFsaWRhdGUnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHNjb3BlQXJyID0gSlNPTi5wYXJzZShmb3JtWyduZXR0ZS1zdWJtaXR0ZWRCeSddLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXR0ZS12YWxpZGF0aW9uLXNjb3BlJykgfHwgJ1tdJyk7XG4gICAgICAgICAgICBpZiAoc2NvcGVBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBuZXcgUmVnRXhwKCdeKCcgKyBzY29wZUFyci5qb2luKCctfCcpICsgJy0pJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGVcbiAgICAgICAgICAgICAgICAvLyBOZXR0ZS5zaG93Rm9ybUVycm9ycyhmb3JtLCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFkaW9zID0ge30sIGksIGVsZW07XG4gICAgICAgIC8vIExpdmVGb3JtOiBhZGRpdGlvblxuICAgICAgICB2YXIgc3VjY2VzcyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVsZW0gPSBmb3JtLmVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZWxlbS50YWdOYW1lICYmICEoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgaW4ge2lucHV0OiAxLCBzZWxlY3Q6IDEsIHRleHRhcmVhOiAxLCBidXR0b246IDF9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgIGlmIChyYWRpb3NbZWxlbS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFkaW9zW2VsZW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHNjb3BlICYmICFlbGVtLm5hbWUucmVwbGFjZSgvXVxcW3xcXFt8XXwkL2csICctJykubWF0Y2goc2NvcGUpKSB8fCBOZXR0ZS5pc0Rpc2FibGVkKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpdmVGb3JtOiBhZGRpdGlvblxuICAgICAgICAgICAgc3VjY2VzcyA9IE5ldHRlLnZhbGlkYXRlQ29udHJvbChlbGVtKSAmJiBzdWNjZXNzO1xuICAgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFMaXZlRm9ybS5vcHRpb25zLnNob3dBbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGVcbiAgICAgICAgICAgIC8qaWYgKCFOZXR0ZS52YWxpZGF0ZUNvbnRyb2woZWxlbSwgbnVsbCwgb25seUNoZWNrKSAmJiAhTmV0dGUuZm9ybUVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpdmVGb3JtOiBjaGFuZ2VcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG5cbiAgICAgICAgLy8gTGl2ZUZvcm06IG9yaWdpbmFsIG5ldHRlRm9ybXMuanMgY29kZVxuICAgICAgICAvKnZhciBzdWNjZXNzID0gIU5ldHRlLmZvcm1FcnJvcnMubGVuZ3RoO1xuICAgICAgICBOZXR0ZS5zaG93Rm9ybUVycm9ycyhmb3JtLCBOZXR0ZS5mb3JtRXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7Ki9cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpbnB1dCBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBOZXR0ZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnRzID0gZWxlbS5mb3JtLmVsZW1lbnRzOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0ubmFtZSA9PT0gZWxlbS5uYW1lICYmICFlbGVtZW50c1tpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQ7XG4gICAgfTtcblxuXG4gICAgLy8gTGl2ZUZvcm06IGNoYW5nZVxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBOZXR0ZS5hZGRFcnJvciA9IGZ1bmN0aW9uIChlbGVtLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIExpdmVGb3JtOiBhZGRpdGlvblxuICAgICAgICB2YXIgbm9MaXZlVmFsaWRhdGlvbiA9IExpdmVGb3JtLmhhc0NsYXNzKGVsZW0sIExpdmVGb3JtLm9wdGlvbnMuZGlzYWJsZUxpdmVWYWxpZGF0aW9uQ2xhc3MpO1xuICAgICAgICAvLyBVc2VyIGV4cGxpY2l0bHkgZGlzYWJsZWQgbGl2ZS12YWxpZGF0aW9uIHNvIHdlIHdhbnQgdG8gc2hvdyBzaW1wbGUgYWxlcnRzXG4gICAgICAgIGlmIChub0xpdmVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBub3RpZnkgZXJyb3JzIGZvciBlbGVtZW50cyB3aXRoIGRpc2FibGVkIGxpdmUgdmFsaWRhdGlvbiAoYnV0IG9ubHkgZXJyb3JzIGFuZCBub3QgZHVyaW5nIG9uTG9hZFZhbGlkYXRpb24pXG4gICAgICAgICAgICBpZiAobWVzc2FnZSAmJiAhTGl2ZUZvcm0uZ2V0Rm9ybVByb3BlcnR5KGVsZW0uZm9ybSwgXCJoYXNFcnJvclwiKSAmJiAhTGl2ZUZvcm0uZ2V0Rm9ybVByb3BlcnR5KGVsZW0uZm9ybSwgXCJvbkxvYWRWYWxpZGF0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0uZm9jdXMgJiYgIUxpdmVGb3JtLmdldEZvcm1Qcm9wZXJ0eShlbGVtLmZvcm0sIFwiaGFzRXJyb3JcIikpIHtcbiAgICAgICAgICAgIGlmICghTGl2ZUZvcm0uZm9jdXNpbmcpIHtcbiAgICAgICAgICAgICAgICBMaXZlRm9ybS5mb2N1c2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBMaXZlRm9ybS5mb2N1c2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbCBieSBkZWZpbmVkIG9mZnNldCAoaWYgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogV2UgdXNlIGl0IHdpdGggc2V0VGltZXRvdXQgYmVjYXVzZSBJRTkgZG9lc24ndCBhbHdheXMgY2F0Y2ggaW5zdGFudCBzY3JvbGxUbyByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2N1c09mZnNldFkgPSBMaXZlRm9ybS5vcHRpb25zLmZvY3VzU2NyZWVuT2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzT2Zmc2V0WSAhPT0gZmFsc2UgJiYgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPCBmb2N1c09mZnNldFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIGZvY3VzT2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub0xpdmVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBMaXZlRm9ybS5hZGRFcnJvcihlbGVtLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGVcbiAgICAvKi8hKipcbiAgICAgKiBBZGRzIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHF1ZXVlLlxuICAgICAqIS9cbiAgICBOZXR0ZS5hZGRFcnJvciA9IGZ1bmN0aW9uKGVsZW0sIG1lc3NhZ2UpIHtcbiAgICAgICAgTmV0dGUuZm9ybUVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW0sXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgIH07Ki9cblxuXG4gICAgLy8gTGl2ZUZvcm06IG9yaWdpbmFsIG5ldHRlRm9ybXMuanMgY29kZVxuICAgIC8qLyEqKlxuICAgICAqIERpc3BsYXkgZXJyb3IgbWVzc2FnZXMuXG4gICAgICohL1xuICAgIE5ldHRlLnNob3dGb3JtRXJyb3JzID0gZnVuY3Rpb24oZm9ybSwgZXJyb3JzKSB7XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFtdLFxuICAgICAgICAgICAgZm9jdXNFbGVtO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBlcnJvcnNbaV0uZWxlbWVudCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3JzW2ldLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAobWVzc2FnZXMuaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghZm9jdXNFbGVtICYmIGVsZW0uZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNFbGVtID0gZWxlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYWxlcnQobWVzc2FnZXMuam9pbignXFxuJykpO1xuICAgICAgICAgICAgaWYgKGZvY3VzRWxlbSkge1xuICAgICAgICAgICAgICAgIGZvY3VzRWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsqL1xuXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgc2luZ2xlIHJ1bGUuXG4gICAgICovXG4gICAgTmV0dGUudmFsaWRhdGVSdWxlID0gZnVuY3Rpb24gKGVsZW0sIG9wLCBhcmcsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHt2YWx1ZTogTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUoZWxlbSwgdHJ1ZSl9IDogdmFsdWU7XG5cbiAgICAgICAgaWYgKG9wLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICAgICAgICBvcCA9IG9wLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IG9wLnJlcGxhY2UoJzo6JywgJ18nKTtcbiAgICAgICAgb3AgPSBvcC5yZXBsYWNlKC9cXFxcL2csICcnKTtcblxuICAgICAgICB2YXIgYXJyID0gQXJyYXkuaXNBcnJheShhcmcpID8gYXJnLnNsaWNlKDApIDogW2FyZ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gJiYgYXJyW2ldLmNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IGVsZW0uZm9ybS5lbGVtZW50cy5uYW1lZEl0ZW0oYXJyW2ldLmNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGNvbnRyb2wgPT09IGVsZW0gPyB2YWx1ZS52YWx1ZSA6IE5ldHRlLmdldEVmZmVjdGl2ZVZhbHVlKGNvbnRyb2wsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5ldHRlLnZhbGlkYXRvcnNbb3BdXG4gICAgICAgICAgICA/IE5ldHRlLnZhbGlkYXRvcnNbb3BdKGVsZW0sIEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyciA6IGFyclswXSwgdmFsdWUudmFsdWUsIHZhbHVlKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG5cblxuICAgIE5ldHRlLnZhbGlkYXRvcnMgPSB7XG4gICAgICAgIGZpbGxlZDogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJyAmJiBlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsICE9PSAnJyAmJiB2YWwgIT09IGZhbHNlICYmIHZhbCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICYmICghQXJyYXkuaXNBcnJheSh2YWwpIHx8ICEhdmFsLmxlbmd0aClcbiAgICAgICAgICAgICAgICAmJiAoIXdpbmRvdy5GaWxlTGlzdCB8fCAhKHZhbCBpbnN0YW5jZW9mIHdpbmRvdy5GaWxlTGlzdCkgfHwgdmFsLmxlbmd0aCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmxhbms6IGZ1bmN0aW9uIChlbGVtLCBhcmcsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICFOZXR0ZS52YWxpZGF0b3JzLmZpbGxlZChlbGVtLCBhcmcsIHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0dGUudmFsaWRhdGVDb250cm9sKGVsZW0sIG51bGwsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnICsgdmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHRydWUgPyAnMScgOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdO1xuICAgICAgICAgICAgYXJnID0gQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogW2FyZ107XG4gICAgICAgICAgICBsb29wOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkxID0gMCwgbGVuMSA9IHZhbC5sZW5ndGg7IGkxIDwgbGVuMTsgaTErKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIgPSBhcmcubGVuZ3RoOyBpMiA8IGxlbjI7IGkyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b1N0cmluZyh2YWxbaTFdKSA9PT0gdG9TdHJpbmcoYXJnW2kyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBub3RFcXVhbDogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogIU5ldHRlLnZhbGlkYXRvcnMuZXF1YWwoZWxlbSwgYXJnLCB2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1pbkxlbmd0aDogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLnZhbGlkaXR5LnRvb1Nob3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0udmFsaWRpdHkuYmFkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbC5sZW5ndGggPj0gYXJnO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1heExlbmd0aDogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLnZhbGlkaXR5LnRvb0xvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsLmxlbmd0aCA8PSBhcmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0udmFsaWRpdHkudG9vU2hvcnQgfHwgZWxlbS52YWxpZGl0eS50b29Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0udmFsaWRpdHkuYmFkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogW2FyZywgYXJnXTtcbiAgICAgICAgICAgIHJldHVybiAoYXJnWzBdID09PSBudWxsIHx8IHZhbC5sZW5ndGggPj0gYXJnWzBdKSAmJiAoYXJnWzFdID09PSBudWxsIHx8IHZhbC5sZW5ndGggPD0gYXJnWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbWFpbDogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKC9eKFwiKFsgISMtW1xcXS1+XXxcXFxcWyAtfl0pK1wifFstYS16MC05ISMkJSYnKisvPT9eX2B7fH1+XSsoXFwuWy1hLXowLTkhIyQlJicqKy89P15fYHt8fX5dKykqKUAoWzAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0oWy0wLTlhLXpcXHUwMEMwLVxcdTAyRkZcXHUwMzcwLVxcdTFFRkZdezAsNjF9WzAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0pP1xcLikrW2EtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0oWy0wLTlhLXpcXHUwMEMwLVxcdTAyRkZcXHUwMzcwLVxcdTFFRkZdezAsMTd9W2EtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0pPyQvaSkudGVzdCh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVybDogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEoL15bYS16XFxkKy4tXSs6LykudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJ2h0dHA6Ly8nICsgdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgvXmh0dHBzPzpcXC9cXC8oKChbLV8wLTlhLXpcXHUwMEMwLVxcdTAyRkZcXHUwMzcwLVxcdTFFRkZdK1xcLikqWzAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0oWy0wLTlhLXpcXHUwMEMwLVxcdTAyRkZcXHUwMzcwLVxcdTFFRkZdezAsNjF9WzAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0pP1xcLik/W2EtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0oWy0wLTlhLXpcXHUwMEMwLVxcdTAyRkZcXHUwMzcwLVxcdTFFRkZdezAsMTd9W2EtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0pP3xcXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfXxcXFtbMC05YS1mOl17MywzOX1cXF0pKDpcXGR7MSw1fSk/KFxcL1xcUyopPyQvaSkudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnZXhwOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYXJnLm1hdGNoKC9eXFwvKC4qKVxcLyhbaW11XSopJC8pIDogZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0cyAmJiAobmV3IFJlZ0V4cChwYXJ0c1sxXSwgcGFydHNbMl0ucmVwbGFjZSgndScsICcnKSkpLnRlc3QodmFsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhdHRlcm46IGZ1bmN0aW9uIChlbGVtLCBhcmcsIHZhbCwgdmFsdWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14oPzonICsgYXJnICsgJykkJywgY2FzZUluc2Vuc2l0aXZlID8gJ3VpJyA6ICd1Jyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKCdeKD86JyArIGFyZyArICcpJCcsIGNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAod2luZG93LkZpbGVMaXN0ICYmIHZhbCBpbnN0YW5jZW9mIEZpbGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ0V4cC50ZXN0KHZhbFtpXS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHAudGVzdCh2YWwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybkNhc2VJbnNlbnNpdGl2ZTogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV0dGUudmFsaWRhdG9ycy5wYXR0ZXJuKGVsZW0sIGFyZywgdmFsLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBudW1lcmljOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInICYmIGVsZW0udmFsaWRpdHkuYmFkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC9eWzAtOV0rJC8pLnRlc3QodmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInICYmIGVsZW0udmFsaWRpdHkuYmFkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC9eLT9bMC05XSskLykudGVzdCh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdmbG9hdCc6IGZ1bmN0aW9uIChlbGVtLCBhcmcsIHZhbCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInICYmIGVsZW0udmFsaWRpdHkuYmFkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvICsvZywgJycpLnJlcGxhY2UoLywvZywgJy4nKTtcbiAgICAgICAgICAgIGlmICgoL14tP1swLTldKlxcLj9bMC05XSskLykudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0udmFsaWRpdHkucmFuZ2VVbmRlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnID09PSBudWxsIHx8IHBhcnNlRmxvYXQodmFsKSA+PSBhcmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0udmFsaWRpdHkucmFuZ2VPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmcgPT09IG51bGwgfHwgcGFyc2VGbG9hdCh2YWwpIDw9IGFyZztcbiAgICAgICAgfSxcblxuICAgICAgICByYW5nZTogZnVuY3Rpb24gKGVsZW0sIGFyZywgdmFsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLnZhbGlkaXR5LnJhbmdlVW5kZXJmbG93IHx8IGVsZW0udmFsaWRpdHkucmFuZ2VPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZykgP1xuICAgICAgICAgICAgICAgICgoYXJnWzBdID09PSBudWxsIHx8IHBhcnNlRmxvYXQodmFsKSA+PSBhcmdbMF0pICYmIChhcmdbMV0gPT09IG51bGwgfHwgcGFyc2VGbG9hdCh2YWwpIDw9IGFyZ1sxXSkpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJtaXR0ZWQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5mb3JtWyduZXR0ZS1zdWJtaXR0ZWRCeSddID09PSBlbGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbGVTaXplOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsW2ldLnNpemUgPiBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGltYWdlOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuRmlsZUxpc3QgJiYgdmFsIGluc3RhbmNlb2Ygd2luZG93LkZpbGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB2YWxbaV0udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gJ2ltYWdlL2dpZicgJiYgdHlwZSAhPT0gJ2ltYWdlL3BuZycgJiYgdHlwZSAhPT0gJ2ltYWdlL2pwZWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAnc3RhdGljJzogZnVuY3Rpb24gKGVsZW0sIGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIHRvZ2dsZXMgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBOZXR0ZS50b2dnbGVGb3JtID0gZnVuY3Rpb24gKGZvcm0sIGVsZW0pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcm1Ub2dnbGVzID0ge307XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybS5lbGVtZW50c1tpXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgaW4ge2lucHV0OiAxLCBzZWxlY3Q6IDEsIHRleHRhcmVhOiAxLCBidXR0b246IDF9KSB7XG4gICAgICAgICAgICAgICAgTmV0dGUudG9nZ2xlQ29udHJvbChmb3JtLmVsZW1lbnRzW2ldLCBudWxsLCBudWxsLCAhZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgaW4gZm9ybVRvZ2dsZXMpIHtcbiAgICAgICAgICAgIE5ldHRlLnRvZ2dsZShpLCBmb3JtVG9nZ2xlc1tpXSwgZWxlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRvZ2dsZXMgb24gZm9ybSBlbGVtZW50LlxuICAgICAqL1xuICAgIE5ldHRlLnRvZ2dsZUNvbnRyb2wgPSBmdW5jdGlvbiAoZWxlbSwgcnVsZXMsIHN1Y2Nlc3MsIGZpcnN0dGltZSwgdmFsdWUpIHtcbiAgICAgICAgcnVsZXMgPSBydWxlcyB8fCBKU09OLnBhcnNlKGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLW5ldHRlLXJ1bGVzJykgfHwgJ1tdJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHt2YWx1ZTogTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUoZWxlbSl9IDogdmFsdWU7XG5cbiAgICAgICAgdmFyIGhhcyA9IGZhbHNlLFxuICAgICAgICAgICAgaGFuZGxlZCA9IFtdLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBOZXR0ZS50b2dnbGVGb3JtKGVsZW0uZm9ybSwgZWxlbSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VyU3VjY2VzcztcblxuICAgICAgICBmb3IgKHZhciBpZCA9IDAsIGxlbiA9IHJ1bGVzLmxlbmd0aDsgaWQgPCBsZW47IGlkKyspIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaWRdLFxuICAgICAgICAgICAgICAgIG9wID0gcnVsZS5vcC5tYXRjaCgvKH4pPyhbXj9dKykvKSxcbiAgICAgICAgICAgICAgICBjdXJFbGVtID0gcnVsZS5jb250cm9sID8gZWxlbS5mb3JtLmVsZW1lbnRzLm5hbWVkSXRlbShydWxlLmNvbnRyb2wpIDogZWxlbTtcblxuICAgICAgICAgICAgaWYgKCFjdXJFbGVtKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1clN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5uZWcgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICBydWxlLm9wID0gb3BbMl07XG4gICAgICAgICAgICAgICAgY3VyU3VjY2VzcyA9IE5ldHRlLnZhbGlkYXRlUnVsZShjdXJFbGVtLCBydWxlLm9wLCBydWxlLmFyZywgZWxlbSA9PT0gY3VyRWxlbSA/IHZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyU3VjY2VzcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5uZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyU3VjY2VzcyA9ICFjdXJTdWNjZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGN1clN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHJ1bGUucnVsZXMgJiYgTmV0dGUudG9nZ2xlQ29udHJvbChlbGVtLCBydWxlLnJ1bGVzLCBjdXJTdWNjZXNzLCBmaXJzdHRpbWUsIHZhbHVlKSkgfHwgcnVsZS50b2dnbGUpIHtcbiAgICAgICAgICAgICAgICBoYXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjdXJFbGVtLnRhZ05hbWUgPyBjdXJFbGVtLm5hbWUgOiBjdXJFbGVtWzBdLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHMgPSBjdXJFbGVtLnRhZ05hbWUgPyBjdXJFbGVtLmZvcm0uZWxlbWVudHMgOiBjdXJFbGVtO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxzW2ldLm5hbWUgPT09IG5hbWUgJiYgaGFuZGxlZC5pbmRleE9mKGVsc1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWQucHVzaChlbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkMiBpbiBydWxlLnRvZ2dsZSB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJ1bGUudG9nZ2xlLCBpZDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtVG9nZ2xlc1tpZDJdID0gZm9ybVRvZ2dsZXNbaWQyXSB8fCAocnVsZS50b2dnbGVbaWQyXSA/IGN1clN1Y2Nlc3MgOiAhY3VyU3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhcztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBvciBoaWRlcyBIVE1MIGVsZW1lbnQuXG4gICAgICovXG4gICAgTmV0dGUudG9nZ2xlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCB2aXNpYmxlLCBzcmNFbGVtZW50KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgaWYgKC9eXFx3W1xcdy46LV0qJC8udGVzdChzZWxlY3RvcikpIHsgLy8gaWRcbiAgICAgICAgICAgIHNlbGVjdG9yID0gJyMnICsgc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1zW2ldLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgaGFuZGxlcnMuXG4gICAgICovXG4gICAgTmV0dGUuaW5pdEZvcm0gPSBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgICBOZXR0ZS50b2dnbGVGb3JtKGZvcm0pO1xuXG4gICAgICAgIGlmIChmb3JtLm5vVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm0ubm9WYWxpZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gTGl2ZUZvcm06IGFkZGl0aW9uXG4gICAgICAgIExpdmVGb3JtLmZvcm1zW2Zvcm0uaWRdID0ge1xuICAgICAgICAgICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgb25Mb2FkVmFsaWRhdGlvbjogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIU5ldHRlLnZhbGlkYXRlRm9ybShmb3JtKSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaXZlRm9ybTogYWRkaXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBMaXZlRm9ybS5zZXR1cEhhbmRsZXJzKGZvcm0uZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgTGl2ZUZvcm0ucHJvY2Vzc1NlcnZlckVycm9ycyhmb3JtLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5ldHRlLmluaXRPbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE5ldHRlLmFkZEV2ZW50KGRvY3VtZW50LCAnRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGVcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuZm9ybXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybS5lbGVtZW50c1tqXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV0dGUtcnVsZXMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXR0ZS5pbml0Rm9ybShmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE5ldHRlLmFkZEV2ZW50KGRvY3VtZW50LmJvZHksICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmZvcm0gJiYgdGFyZ2V0LnR5cGUgaW4ge3N1Ym1pdDogMSwgaW1hZ2U6IDF9KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmZvcm1bJ25ldHRlLXN1Ym1pdHRlZEJ5J10gPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIExpdmVGb3JtOiBhZGRpdGlvblxuICAgICAgICAgICAgTmV0dGUuaW5pdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTGl2ZUZvcm06IGFkZGl0aW9uXG4gICAgLyoqXG4gICAgICogSW5pdCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gY2FzZSB1c2FnZSBhcyBtb2R1bGVcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBOZXR0ZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LmZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmZvcm1zW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm0uZWxlbWVudHNbal0uZ2V0QXR0cmlidXRlKCdkYXRhLW5ldHRlLXJ1bGVzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgTmV0dGUuaW5pdEZvcm0oZm9ybSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKExpdmVGb3JtLmhhc0NsYXNzKGZvcm0sICd2YWxpZGF0ZS1vbi1sb2FkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHNvIG5pY2Ugd2F5LCBidXQgSSBkb24ndCB3YW50IHRvIHNwb2lsIHZhbGlkYXRlRm9ybSwgdmFsaWRhdGVDb250cm9sIGFuZCBvdGhlciBtZXRob2RzIHdpdGggYW5vdGhlciBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIExpdmVGb3JtLnNldEZvcm1Qcm9wZXJ0eShmb3JtLCBcIm9uTG9hZFZhbGlkYXRpb25cIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBOZXR0ZS52YWxpZGF0ZUZvcm0oZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXZlRm9ybS5zZXRGb3JtUHJvcGVydHkoZm9ybSwgXCJvbkxvYWRWYWxpZGF0aW9uXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE5ldHRlLmFkZEV2ZW50KGRvY3VtZW50LmJvZHksICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5mb3JtICYmIHRhcmdldC50eXBlIGluIHtzdWJtaXQ6IDEsIGltYWdlOiAxfSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5mb3JtWyduZXR0ZS1zdWJtaXR0ZWRCeSddID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LlxuICAgICAqL1xuICAgIE5ldHRlLmlzQXJyYXkgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGEgc3BlY2lmaWVkIHZhbHVlIHdpdGhpbiBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBOZXR0ZS5pbkFycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFsKSB7XG4gICAgICAgIGlmIChbXS5pbmRleE9mKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsKSA+IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgc3RyaW5nIHRvIHdlYiBzYWZlIGNoYXJhY3RlcnMgW2EtejAtOS1dIHRleHQuXG4gICAgICovXG4gICAgTmV0dGUud2ViYWxpemUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICBzID0gcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgcmVzID0gJycsIGksIGNoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSBOZXR0ZS53ZWJhbGl6ZVRhYmxlW3MuY2hhckF0KGkpXTtcbiAgICAgICAgICAgIHJlcyArPSBjaCA/IGNoIDogcy5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC9bXmEtejAtOV0rL2csICctJykucmVwbGFjZSgvXi18LSQvZywgJycpO1xuICAgIH07XG5cbiAgICBOZXR0ZS53ZWJhbGl6ZVRhYmxlID0ge1xcdTAwZTE6ICdhJywgXFx1MDBlNDogJ2EnLCBcXHUwMTBkOiAnYycsIFxcdTAxMGY6ICdkJywgXFx1MDBlOTogJ2UnLCBcXHUwMTFiOiAnZScsIFxcdTAwZWQ6ICdpJywgXFx1MDEzZTogJ2wnLCBcXHUwMTQ4OiAnbicsIFxcdTAwZjM6ICdvJywgXFx1MDBmNDogJ28nLCBcXHUwMTU5OiAncicsIFxcdTAxNjE6ICdzJywgXFx1MDE2NTogJ3QnLCBcXHUwMGZhOiAndScsIFxcdTAxNmY6ICd1JywgXFx1MDBmZDogJ3knLCBcXHUwMTdlOiAneid9O1xuXG4gICAgcmV0dXJuIE5ldHRlO1xufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/live-form-validation/live-form-validation.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;